legend.outside.size = 0.2,
legend.outside.position = "bottom", # added 9,8
frame = FALSE)+
tm_shape(adm10_simple_faoadded_rob) + # was reg_rob_simple
tm_borders(col = NA,  lwd = 0.5)  # lwd was 0.33, col was "grey30",
return (index_map)
}
## plotting without contry borders (reg instead)
create_index_map_no_cntry <- function(r_index, index_label,index_main_title,
colorpal, breakvals,
breaknames = NULL,
color_midpoint = NULL, tocrs = NA){
if (!is.na(tocrs)){
r_index <- project(r_index, tocrs, mask = TRUE)
}
index_map <- tm_shape(r_index) +
tm_raster(palette = colorpal, # try style = "fixed",
breaks = breakvals,
labels = breaknames,
title = index_label,
midpoint = color_midpoint,
legend.is.portrait = FALSE) + # added 9.8.22
#  legend.reverse = TRUE) + # deleted 9.8.22
tm_layout(main.title = index_main_title,
main.title.position = "center",
main.title.size = 1,
legend.bg.color = TRUE,
legend.outside = TRUE,
legend.title.size = 1,
legend.text.size = 1,
legend.outside.size = 0.2,
legend.outside.position = "bottom", # added 9,8
frame = FALSE)+
tm_shape(reg_rob_simple  ) +
tm_borders(col = NA,  lwd = 0.5)  # lwd was 0.33, col was "grey30",
return (index_map)
}
# Function to remove outliers. Only needed when calculating global sums
f_raster_without_outliers <- function(myraster_layer) {
# Calculate quantiles for both 0.01 and 0.99
quantiles <- quantile(values(myraster_layer), probs = c(0.01, 0.99), na.rm = T)
# Define classification rules with "from-to-becomes" structure
rcl_outliers <- matrix(c(-Inf, quantiles[1], quantiles[1],
quantiles[2], Inf, quantiles[2]), ncol = 3, byrow = T)
# Classify raster values according to rules, with include.lowest and right set
myraster_new <- classify(myraster_layer, rcl_outliers, include.lowest = TRUE, right = NA)
return(myraster_new)
}
f_global_sum_without_outliers <- function(myraster_layer) {
out_values <- quantile(values(myraster_layer), probs = 0.99, na.rm = T)
myraster_new <- myraster_layer
myraster_new[myraster_new > out_values] <- NA
totsum <- global(myraster_new, fun = "sum", na.rm = T)
return(totsum)
}
land_mask <- ifel(cntry_raster > 0, 1, NA)
plot(land_mask) # plot to get rid of error
plot(cntry_raster) # Error in x$.self$finalize() : attempt to apply non-function
cntry_raster
# ---------------------------------------------------------- FAOSTAT download
foodBalanceSheets_semiraw <-
here("Data", "Input", "faostat", "foodBalanceSheets_E_All_Data_NOFLAG.csv") %>%
read.csv() %>%
dplyr::select(-Element.Code,-Unit ,-c(Y2011:Y2019))
my_elementlist_fao <- c(
"Production","Food supply quantity (kg/capita/yr)",
"Food supply (kcal/capita/day)", "Protein supply quantity (g/capita/day)"
)
my_itemlist_fao_animals <- c("Meat", "Bovine Meat", "Mutton & Goat Meat")
# ---------------------------------------- FAOSTAT animal protein to kcal
fbs_animals <- foodBalanceSheets_semiraw %>%
filter(Item %in% my_itemlist_fao_animals,
Element %in% my_elementlist_fao)
## pivot wider
fbs_animals_wide <- fbs_animals %>%
pivot_wider(names_from = Element, values_from = Y2010) %>%
rename(prod_1000mt = "Production", # eg numbers in FIN equals Lukestat
supply.KgCapYr = "Food supply quantity (kg/capita/yr)",
supply.KcalCapD = "Food supply (kcal/capita/day)",
prot.gCapD = "Protein supply quantity (g/capita/day)") %>%
## how many kcal do we get from amount of meat containing one kg of protein - required for simple conversion from protein production to energy production
## create variable protein to kcal
mutate(one_kg_prot_to_kcal =  (supply.KcalCapD / prot.gCapD) * 1000,
protein_fraction = (prot.gCapD*365/1000) / supply.KgCapYr) %>% # protein fraction for meat products -- not even needed
dplyr::select(-Item.Code) %>%
mutate_all(function(x) ifelse(is.nan(x) | is.infinite(x), NA, x))  # convert NaN values to NA
# fill empty columns (values 0 or NA) with global averages similardly as done earlier with crops
## ex with Bovine meat. First, find global average for one_kg_prot_to_kcal
# one_kg_prot_to_kcal_bovine <- fbs_animals_wide %>%
#   filter(Item == "Bovine Meat", Area == "World") %>%
#   pull(one_kg_prot_to_kcal)
#
#   ## then replace 0 or NA values with this value
# test_bovine  <- fbs_animals_wide %>%
#   filter(Item == "Bovine Meat") %>%
#   mutate(one_kg_prot_to_kcal =
#            ifelse(is.na(one_kg_prot_to_kcal) | one_kg_prot_to_kcal == 0 , # if one_kg_prot_to_kcal fraction = NA or 0,
#                                    one_kg_prot_to_kcal_bovine, # fill with the global average value
#                                    one_kg_prot_to_kcal))  # otherwise let it just be
# do this with function for all meat items and fill also protein_fraction col if that's needed later
f_fill_missing_nutritient_values_animals<- function(animalcategory) {
## pull one_kg_prot_to_kcal for spesific animal species
one_kg_prot_to_kcal_animalcategory <- fbs_animals_wide %>%
filter(Item == animalcategory, Area == "World") %>%
pull(one_kg_prot_to_kcal)
## pull protein fraction for spesific crop
protein_fraction_animalcategory <- fbs_animals_wide %>%
filter(Item == animalcategory, Area == "World") %>%
pull(protein_fraction)
## fill empty one_kg_prot_to_kcal amd protein_fraction  with global averages
fbs_animals_wide_filled <- fbs_animals_wide %>%
filter(Item == animalcategory) %>%
## fill one_kg_prot_to_kcal column
