resample(., template_rast_5arcmin)
# Plot
r_both_si <- c(SI_rainfed_agg, SI_current_irri_agg)
(plt_SI_v3.0_twomaps <- create_index_map(r_index = r_both_si, tocrs = "ESRI:54030",
index_main_title = "SI for food crops over 1980-2009: subset 1to17 with current irri and no subset with rainfed",
index_label = "",
colorpal = pal_agb,
breakvals =  c(1, 33, 75, Inf),
breaknames = c("Marginally suitable (1 < SI < 33 )",
"Moderately suitable (33 <= SI <= 75 )", "Highly suitable (SI > 75)")) )
(plt_SI_v3.0_twomaps2 <- create_index_map(r_index = r_both_si, tocrs = "ESRI:54030",
index_main_title = "SI for food crops over 1980-2009\n subset 1to17 with current irri and\n no subset with rainfed",
index_label = "",
colorpal = pal_agb,
breakvals =  c(1, 10, 20, 30, 40, 50, 60, 75, Inf),
breaknames =  ))
tmap_save(plt_SI_v3.0_twomaps2,
here("Delete", "SI_rainfedVSirrigated_5arcmin.pdf"))
# Plot 30 as
r_both_si_30as <- c(SI_rainfed, SI_current_irri)
plt_SI_v3.0_twomaps_30as <- create_index_map(r_index = r_both_si_30as, tocrs = "ESRI:54030",
index_main_title = "SI for food crops over 1980-2009\n subset 1to17 with current irri and\n no subset with rainfed",
index_label = "",
colorpal = pal_agb,
breakvals =  c(1, 10, 20, 30, 40, 50, 60, 75, Inf),
breaknames =  )
tmap_save(plt_SI_v3.0_twomaps_30as,
here("Delete", "SI_rainfedVSirrigated_30as.pdf"))
plt_SI_v3.0_rainfed_30as <- create_index_map(r_index = SI_rainfed, tocrs = "ESRI:54030",
index_main_title = "SI for food crops over 1980-2009\n subset 1to17 with current irri and\n no subset with rainfed",
index_label = "",
colorpal = pal_agb,
breakvals =  c(1, 10, 20, 30, 40, 50, 60, 75, Inf),
breaknames =  )
tmap_save(SI_rainfed,
here("Delete", "SI_rainfed_30as.pdf"))
# Get intermediate data
# palettes
pal_npp <- scico(n = 5,begin = 0.6, end = 1, palette = "corkO")
# Practicalities
# !!!! numeroi scriptit lopuksi: missä järjestyksessä tulee ajaa
# !!! kehittele funktio, joka laskee 99% quantilen kullekin layerille ja trimmaa rasteria sen mukaan?
# if (!dir.exists("Data")){ dir.create("Data") }
# if (!dir.exists("Figures")){ dir.create("Figures") } # modify and add to packages etc
# if (!dir.exists("Data/Input")){ dir.create("Data/Input") }
# if (!dir.exists("Data/Intermediate_input")){ dir.create("Data/Intermediate_input") }
# if (!dir.exists("Data/Output")){ dir.create("Data/Output") }
# Packages etc
# packages <- c("tidyverse", "terra", "tmap", "scico",
#               "sf", "here", "tictoc", "rmapshaper",  "countrycode",
#               "readxl", "broom", "tidyr", "flextable", "gridExtra")
#
# not_installed <- packages[!(packages %in% installed.packages()[,"Package"])]
# #if(length(not_installed)){install.packages(not_installed)}
#
# if (length(not_installed) > 0) {
#   install.packages(not_installed)
# } # possible that "proxy" and "httpcode" (sf and flextable dependencies)
# # need to be installed separately
#
#
# lapply(packages, library, character.only = TRUE)
# same as
library(tidyverse); library(terra); library(sf)
library(scico); library(tmap)
library(here); library(tictoc); library(rmapshaper)
library(countrycode);library(readxl)
library(broom); library(tidyr)
library(Rfast); library(matrixStats)
library(flextable); library(gridExtra)
# options, mainly for terra package
#terraOptions(tempdir= here("Temp_R"))
terraOptions()
terraOptions(memfrac=0.9,
verbose = F)
mem_info(rast())
tempdir() # where are temporary files
terraOptions() # free_RAM()/1e6 # amount of available RAM
# timestep
timestep_2000_2015 <- 2000:2015 # !! begins in 2000
timestep_2000_2020 <- 2000:2020
timestep_2001_2015 <- 2001:2015 # is this even needed?
timestep_2001_2020 <- 2001:2020
timestep_climnorm <- 1991:2020
template_rast_5arcmin <- rast(nrows=2160, ncols=4320,
crs = "EPSG:4326")
e <- ext(-180, 180, -90, 90)
# Polygons
adm_10m <- here("Data", "Input", "ne_10m_admin_0_countries.shp") |>
read_sf()
Finland_geom <- adm_10m %>% filter(ADMIN == "Finland") %>% dplyr::select(ADMIN) |>
as("Spatial") |>   vect()
#Finland_ext <- ext(21, 31.5, 60, 70)
# -------------------------------------------------------- create country raster
# adm10_simple <- ms_simplify(adm_10m) #  203 row -- was 258
#
# # #change adm10 iso codes to fao codes
# adm10_simple_faoadded <- adm10_simple %>%
#   dplyr::select(ADMIN, NAME, SOVEREIGNT, ISO_A3_EH, REGION_UN) %>%
#   as.data.frame() %>%
#   st_drop_geometry()
# #
# adm10_simple_faoadded <- adm10_simple_faoadded %>%
#   mutate(fao_from_iso3eh = countrycode(.$ISO_A3_EH, origin = "iso3c", destination = "fao"),
#          # find fao code also using name of sovereignts (combine these cols later to get match)
#          fao_from_SOVEREIGNT = countrycode(.$SOVEREIGNT, origin = "country.name",  destination = "fao"))
# ## warns that some are missing. However, either fao_from_iso3eh or fao_from_SOVEREIGNT includes most
#
# ## give Somaliland FAO code of Somalia
# adm10_simple_faoadded <- adm10_simple_faoadded %>%
#   rows_update(., tibble(
#     SOVEREIGNT = "Somaliland",
#     fao_from_SOVEREIGNT = (filter(adm10_simple_faoadded, SOVEREIGNT == "Somalia") %>%
#                              pull(fao_from_SOVEREIGNT))))
#
#
#
# # ## combine cols fao_from_iso3eh and fao_from_SOVEREIGNT.
# # ## If any of the columns has value, this value will be the FAO_ID
# adm10_simple_faoadded <- adm10_simple_faoadded %>%
#   mutate(FAO_ID = coalesce(fao_from_iso3eh, fao_from_SOVEREIGNT)) %>%
#   filter(SOVEREIGNT != "Antarctica")  ## drop antarctica
#
# ## give South Sudan FAO code of Sudan
# # adm10_simple_faoadded <- adm10_simple_faoadded %>%
# #   rows_update(., tibble(
# #     SOVEREIGNT = "South Sudan",
# #     FAO_ID = (filter(adm10_simple_faoadded, SOVEREIGNT == "Sudan") %>%
# #                              pull(FAO_ID))))
#
# adm10_simple_faoadded <- st_as_sf(adm10_simple_faoadded)
# # save for intermediate use- --> note that South Sudan = Sudan code
# st_write(adm10_simple_faoadded,
#          here("Data", "Intermediate_input", "adm10_simple_faoadded.gpkg"),
#          append = FALSE)
# odd countries
# adm10_simple_faoadded %>%
#   filter(ISO_A3_EH == -99) %>% dplyr::select(SOVEREIGNT) %>%
#   st_drop_geometry()
## to be bit faster save and read this file
# st_write(adm10_simple_faoadded, here("Data", "Intermediate_input", "adm10_simple_faoadded.gpkg"))
adm10_simple_faoadded <-
here("Data", "Intermediate_input", "adm10_simple_faoadded.gpkg") %>%
st_read()
## convert to raster
cntry_raster <- rasterize(vect(adm10_simple_faoadded),
template_rast_5arcmin, field = "FAO_ID")
plot(cntry_raster, main = "Antarctica neede or not?")
## convert to rob
adm10_simple_faoadded_rob <-  adm10_simple_faoadded %>%
st_transform(., crs = "ESRI:54030")
# -------------------------------------------------------- not sure which data to use for countries
# --------------------------------------------------------
# admin borders originally created by Vili
# possible to derive from adm10m using e.g package "countryname"
# adm0_vili <-  here("Data", "Input", "adm0_polygons_025dgr.shp") %>%
#   read_sf() %>%
#   dplyr::select(ADMIN, ISO_3166_1, FAO_ID, NAME)
#
# adm0_vili_vecto <- adm0_vili %>% as("Spatial") %>% vect() # 168 unique
#
# #
#
#
# # combine adm10m data with fao id
# df_adm10m <- as.data.frame(adm_10m) %>%
#   dplyr::select(ADMIN, NAME, geometry)
# df_adm0_vili <- as.data.frame(adm0_vili)
#
# # join. We want to preserve countries of df_adm0_vili but add more precise geometries
# df_adm_10m_fao_id <-
#   left_join(df_adm0_vili,
#             df_adm10m, by = c("ADMIN", "NAME" )) %>% # 176 obs.
#   # Combined by name as did not find country codes
#   dplyr::select(ADMIN, NAME, ISO_3166_1, FAO_ID,  geometry.y) %>%
#   rename(geometry = geometry.y)
# head(df_adm_10m_fao_id)
#
# # df_adm0_vili %>% filter(ADMIN == "Finland") %>% head()
# # df_adm_10m_fao_id %>% filter(ADMIN == "Finland") %>% head()
#
#
#
# adm_10m_fao_id_simple <- st_as_sf(df_adm_10m_fao_id) %>%
#   ms_simplify()
# adm_10m_fao_id_simple_rob <- adm_10m_fao_id_simple %>%
#   st_transform(., crs = "ESRI:54030")
# ---------------------------------------------------------------
#
#
# cntry_raster <- rasterize(vect(adm_10m_fao_id_simple),
#                           template_rast_5arcmin, field = "FAO_ID")
#
# --------------------------------------------------------
# --------------------------------------------------------
## regions
reg <- here("Data", "Input", "reg_mollw.gpkg") |>  st_read()
reg_rob <- st_transform(reg, crs = "ESRI:54030")
reg_wgs <- st_transform(reg, crs = "EPSG:4326")
reg_wgs_vect <- vect(as(reg_wgs, "Spatial"))
#
reg_rob <- reg_rob |>
mutate(subregion = c("Australia and Oceania", "Central America",
"East Asia", "Eastern Europe and Central Asia",
"Ice", "South Asia", "South America", "Middle East",
"Sub-Saharan Africa", "North Africa", "North America",
"Southeast Asia", "Western Europe")) #|>   filter(subregion != "Ice") # maybe not needed ## it is needed for figs
# simplify only for plotting
# reg_rob_simple <- ms_simplify(reg_rob) # Remove ice or not?
# st_write(reg_rob_simple, here("Data", "Intermediate_input", "reg_rob_simple.gpkg"))
reg_rob_simple <- here("Data", "Intermediate_input", "reg_rob_simple.gpkg") %>% st_read()
## function for cropping and maskin
crop_and_mask <- function(r_data, df_cropmask_polygon){
r_data |>
crop(df_cropmask_polygon) |>
mask(df_cropmask_polygon)
}
## function for plotting
create_index_map <- function(r_index, index_label,index_main_title,
colorpal, breakvals,
breaknames = NULL,
color_midpoint = NULL, tocrs = NA, colorNA = NULL){
if (!is.na(tocrs)){
r_index <- project(r_index, tocrs, mask = TRUE)
}
index_map <- tm_shape(r_index) +
tm_raster(palette = colorpal, # try style = "fixed",
breaks = breakvals,
labels = breaknames,
title = index_label,
midpoint = color_midpoint,
colorNA = colorNA,
legend.is.portrait = FALSE) + # added 9.8.22
#  legend.reverse = TRUE) + # deleted 9.8.22
tm_layout(main.title = index_main_title,
main.title.position = "center",
main.title.size = 1,
legend.bg.color = TRUE,
legend.outside = TRUE,
legend.title.size = 1,
legend.text.size = 1,
legend.outside.size = 0.2,
legend.outside.position = "bottom", # added 9,8
frame = FALSE)+
tm_shape(adm10_simple_faoadded_rob) + # was reg_rob_simple
tm_borders(col = NA,  lwd = 0.5)  # lwd was 0.33, col was "grey30",
return (index_map)
}
## plotting without contry borders (reg instead)
create_index_map_no_cntry <- function(r_index, index_label,index_main_title,
colorpal, breakvals,
breaknames = NULL,
color_midpoint = NULL, tocrs = NA, colorNA = NULL){
if (!is.na(tocrs)){
r_index <- project(r_index, tocrs, mask = TRUE)
}
index_map <- tm_shape(r_index) +
tm_raster(palette = colorpal, # try style = "fixed",
breaks = breakvals,
labels = breaknames,
title = index_label,
midpoint = color_midpoint,
legend.is.portrait = FALSE) + # added 9.8.22
#  legend.reverse = TRUE) + # deleted 9.8.22
tm_layout(main.title = index_main_title,
main.title.position = "center",
main.title.size = 1,
legend.bg.color = TRUE,
legend.outside = TRUE,
legend.title.size = 1,
legend.text.size = 1,
legend.outside.size = 0.2,
legend.outside.position = "bottom", # added 9,8
frame = FALSE)+
tm_shape(reg_rob_simple  ) +
tm_borders(col = NA,  lwd = 0.5)  # lwd was 0.33, col was "grey30",
return (index_map)
}
# Function to remove outliers. Only needed when calculating global sums
f_raster_without_outliers <- function(myraster_layer) {
# Calculate quantiles for both 0.01 and 0.99
quantiles <- quantile(values(myraster_layer), probs = c(0.01, 0.99), na.rm = T)
# Define classification rules with "from-to-becomes" structure
rcl_outliers <- matrix(c(-Inf, quantiles[1], quantiles[1],
quantiles[2], Inf, quantiles[2]), ncol = 3, byrow = T)
# Classify raster values according to rules, with include.lowest and right set
myraster_new <- classify(myraster_layer, rcl_outliers, include.lowest = TRUE, right = NA)
return(myraster_new)
}
land_mask <- ifel(cntry_raster > 0, 1, NA)
plot(land_mask)
# get data
fcr_country <-
read_excel(here("Data", "Input", "fromKajsa", "FCRs_bycountry.xlsx")) %>%
filter(Region != is.na(Region))
fcr_country <- fcr_country %>%
mutate(FAO_from_countrynamme = countrycode(.$Country, origin = "country.name",  destination = "fao"))
# Similar
# kok <- fcr_country %>%
#   dplyr::select(Country, FAO_from_countrynamme)
#
# kok2 <- adm10_simple_faoadded %>%
#    dplyr::select(ADMIN, FAO_ID) %>%
#   st_drop_geometry()
# Regional averages
fcr_regional_medians <-
fcr_country %>%
group_by(Region) %>%
summarise(FCR_reg_median = median(FCR_totalFeedDivTotalProtoutput, na.rm = T))
fcr_regional_medians # almost sensible -- what to do with russian?
# Clean data and convert NA and 0 to regional median values
fcr_country_clean <- fcr_country %>%
dplyr::select(Country, FAO_from_countrynamme, Region, FCR_totalFeedDivTotalProtoutput)
# Liitä alueelliset mediaaniarvot alkuperäiseen tietokehykseen
fcr_country_clean <- fcr_country_clean %>%
left_join(fcr_regional_medians, by = "Region")
# Replace NA and zero values with the regional median value
fcr_country_clean <- fcr_country_clean %>%
mutate(
FCR_kgDMperkgProtein = case_when(
is.na(FCR_totalFeedDivTotalProtoutput) ~ FCR_reg_median,  # Replace NA with regional median
FCR_totalFeedDivTotalProtoutput == 0 ~ FCR_reg_median,   # Replace zeros with regional median
.default = FCR_totalFeedDivTotalProtoutput)  # Otherwise, keep the original value
)
fcr_country_clean$FCR_kgDMperkgProtein %>% summary()
# Laske yhteenveto FCR arvoista alueittain
# fcr_country_clean %>%
#   group_by(Region) %>%
#   summarise(
#     Min = min(FCR_kgDMperkgProtein, na.rm = TRUE),
#     Max = max(FCR_kgDMperkgProtein, na.rm = TRUE),
#     Mean = mean(FCR_kgDMperkgProtein, na.rm = TRUE),
#     Median = median(FCR_kgDMperkgProtein, na.rm = TRUE),
#     SD = sd(FCR_kgDMperkgProtein, na.rm = TRUE)
#   )
######################################################## combine with geometries
adm_10m_fao_id_simple_combined_with_fcr <-
fcr_country_clean %>%
left_join(adm10_simple_faoadded, .,
by = c("FAO_ID" = "FAO_from_countrynamme"))
# Fill missing countries. If a FCR value of a country is missing, fill it with region median FCR value
# Update the 'Region' column based on the conditions for 'REGION_UN'
adm_10m_fao_id_simple_combined_with_fcr <- adm_10m_fao_id_simple_combined_with_fcr %>%
mutate(
Region = case_when(
is.na(Region) & REGION_UN == "Asia" ~ "EASA",  # East and Southeast Asia
is.na(Region) & REGION_UN == "Americas" ~ "LAM",  # Latin America and the Caribbean
is.na(Region) & REGION_UN == "Africa" ~ "SSA",  # Sub-Saharan Africa
is.na(Region) & REGION_UN == "Europe" ~ "EUR",  # Western Europe
is.na(Region) & REGION_UN == "Oceania" ~ "OCE",  # Oceania
.default =  Region  # Otherwise, keep the original value
)
)
# Sitten liitetään fcr_regional_medians uudelleen
adm_10m_fao_id_simple_combined_with_fcr <-
adm_10m_fao_id_simple_combined_with_fcr %>%
left_join(fcr_regional_medians, by = "Region", suffix = c(".x", ""))
# Lopuksi täytetään puuttuvat FCR_kgDMperkgProtein arvot
adm_10m_fao_id_simple_combined_with_fcr <-
adm_10m_fao_id_simple_combined_with_fcr %>%
mutate(
FCR_kgDMperkgProtein = case_when(
is.na(FCR_kgDMperkgProtein) ~ FCR_reg_median,
.default =  FCR_kgDMperkgProtein
)
)
################################################################# rasterize
r_fcr <-
rasterize(adm_10m_fao_id_simple_combined_with_fcr,
template_rast_5arcmin,
field = "FCR_kgDMperkgProtein")
plot(r_fcr, main = "FCR for each country. Unit: kgDM/kgProtein")
r_fcr
writeRaster(r_fcr,
filename = here("Delete", "FCR_totalFeedDivTotalProtoutput.tif"))
#    scico_palette_show()
pal_npp <- scico(n = 5,begin = 0.6, end = 1, palette = "corkO")
# scico(n = 6, palette = "bamako", direction = -1, begin = 0.5, end = 1)
pal_agb <- scico(n = 6, palette = "bamako", direction = -1)
# pal_protein <- scico(n = 10, palette = "hawaii", begin = 0.05,end = 0.85,
#                               direction = -1) # use lajolla instead!
pal_protein_lajolla <- scico(n = 6, palette = "lajolla", begin = 0.15, end = 1, direction = -1) # previously ended 0.85
pal_share_nuuk <- scico(n = 7, palette = "nuuk",  direction = -1)
pal_fcr <- scico(n = 6, palette = "tokyo", direction = -1)
pal_lur <- scico(n =4, palette = "imola", direction = -1)
pal_cv <-  scico(n = 6, palette = "nuuk", direction = -1)
# test
pal_protein_test <-
c("#66c2a5", "#a6d854", "#fee08b", "#fdae61", "#f46d43", "#d53e4f")
pal_share <-
scico(n = 6, palette = "roma", begin = 0.1, end = 0.9, direction = -1)
# FCR
(plt_fcrs <-
create_index_map(r_index =  r_fcr, # or mask to the study area?
tocrs = "ESRI:54030",
index_main_title = "Grass-feed based feed conversion ratios (FCR)",
index_label = "[kg AGB / kg protein]",
colorpal = pal_fcr,
breakvals = c(-Inf,100,200, 300,400,500,Inf),
breaknames = c("<100","100-200","200-300","300-400","400-500", ">500")))
fcr_country <-
read_excel(here("Data", "Input", "fromKajsa", "FCRs_bycountry.xlsx")) %>%
filter(Region != is.na(Region))
# We tested that if we convert e.g. 1000 kg of AGB to protein, the protein output per country is the same if we use individual FCRs or total FCRs
# protein_from_AGB <- fcr_country %>%
#   mutate(ProtKG_withtotal = 1000 / fcr_country$FCR_totalFeedDivTotalProtoutput)
#
# # Now we use relative shares and FCRs designated for different animal species
# protein_from_AGB <- protein_from_AGB %>%
#   mutate(ProtKG_varyingFCR =
#            (1000 * share_dairycows)/  FCR_dairy_cattle +
#            (1000 * (share_dairyheifers + share_meat_bovines))/  FCR_beef_cattle +
#            (1000 * share_dairy_sg)/  FCR_small_rum_dairy +
#            (1000 * (share_dairy_recru_sg+share_meat_sg))/  FCR_small_rum_meat)
# Therefore, it is ok to use one single FCR for a country and later we convert AGB raster to protein using that FCR
# Regional medians
fcr_regional_medians <-
fcr_country %>%
group_by(Region) %>%
summarise(FCR_reg_median = median(FCR_totalFeedDivTotalProtoutput, na.rm = T))
fcr_regional_medians
# Clean data and convert NA and 0 to regional median values
fcr_country_clean <- fcr_country %>%
dplyr::select(Country, Region, FCR_totalFeedDivTotalProtoutput)
# Liitä alueelliset mediaaniarvot alkuperäiseen tietokehykseen
fcr_country_clean <- fcr_country_clean %>%
left_join(fcr_regional_medians, by = "Region")
# Replace NA and zero values with the regional median value
fcr_country_clean <- fcr_country_clean %>%
mutate(
FCR_kgDMperkgProtein = case_when(
is.na(FCR_totalFeedDivTotalProtoutput) ~ FCR_reg_median,  # Replace NA with regional median
FCR_totalFeedDivTotalProtoutput == 0 ~ FCR_reg_median,   # Replace zeros with regional median
.default = FCR_totalFeedDivTotalProtoutput)  # Otherwise, keep the original value
)
# fcr_country_clean <- fcr_country_clean %>%
#   mutate(FCR_kgDMperkgProtein = if_else(is.na(FCR_totalFeedDivTotalProtoutput),
#                                         FCR_reg_median,
#                                         FCR_totalFeedDivTotalProtoutput))
fcr_country_clean$FCR_kgDMperkgProtein %>% summary()
# Summary FCRs by regions
fcr_country_clean %>%
group_by(Region) %>%
summarise(
Min = min(FCR_kgDMperkgProtein, na.rm = TRUE),
Max = max(FCR_kgDMperkgProtein, na.rm = TRUE),
Mean = mean(FCR_kgDMperkgProtein, na.rm = TRUE),
Median = median(FCR_kgDMperkgProtein, na.rm = TRUE),
SD = sd(FCR_kgDMperkgProtein, na.rm = TRUE)
)
# Find  outliers --- no need
# Funktio kvantiilien laskemiseen alueittain
# calculate_regional_quantiles <- function(data, column_name, lower = 0.01, upper = 0.99) {
#   result <- data %>%
#     group_by(Region) %>%
#     summarise(
#       q_lower = quantile(!!sym(column_name), probs = lower, na.rm = TRUE),
#       q_upper = quantile(!!sym(column_name), probs = upper, na.rm = TRUE)
#     )
#
#   return(result)
# }
#
# # Lasketaan kvantiilit vain viimeiselle muuttujalle ja alueittain
# quantile_FCR_by_region <-
#   calculate_regional_quantiles(fcr_country_clean, "FCR_kgDMperkgProtein")
#
# quantile_FCR_by_region
#
#
# # Liitä alueelliset kvantiilit alkuperäiseen tietokehykseen
# fcr_country_clean <- fcr_country_clean %>%
#   left_join(quantile_FCR_by_region, by = "Region")
#
#
#
#
#
#
# # Replace values outside the 0.05 and 0.95 quantiles with the regional median value
# fcr_country_clean <- fcr_country_clean %>%
#   mutate(
#     FCR_kgDMperkgProtein = case_when(
#       # If the value is greater than the upper quantile in that region, replace it with the regional median
#       FCR_kgDMperkgProtein > q_upper ~ FCR_reg_median,
#       # If the value is smaller than the lower quantile in that region, replace it with the regional median
#       FCR_kgDMperkgProtein < q_lower ~ FCR_reg_median,
#       .default = FCR_kgDMperkgProtein)  # Otherwise, keep the original value
#   )
#
# fcr_country_clean # reg medians are same as previously but individual countries now sensible values
# # Compare with Vilmas!
# histogram
ggplot(fcr_country_clean, aes(x = FCR_kgDMperkgProtein)) +
geom_histogram(binwidth = 4, fill = "blue", alpha = 0.7) +
facet_wrap(~ Region) +
labs(
title = "Histogramm FCR_kgDMperkgProtein-values by regions",
x = "FCR_kgDMperkgProtein",
y = "Frekvenssi"
)
# Summary FCRs by regions
fcr_country_clean %>%
group_by(Region) %>%
summarise(
Min = min(FCR_kgDMperkgProtein, na.rm = TRUE),
Max = max(FCR_kgDMperkgProtein, na.rm = TRUE),
Mean = mean(FCR_kgDMperkgProtein, na.rm = TRUE),
Median = median(FCR_kgDMperkgProtein, na.rm = TRUE),
SD = sd(FCR_kgDMperkgProtein, na.rm = TRUE)
)
fcr_country_clean
