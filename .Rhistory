#
writeRaster(r_SIbased_restricted_max_cropland_fraction,
here("Data", "Intermediate_input", "Fraction_of_cropland_max_when_SI_ge_threshold.tif"),
overwrite = T)
r_SIbased_restricted_max_cropland_fraction[[5]] %>% plot()
# convert NA to 0 to make upcoming calculations easier --- check if this is needed
r_SIbased_restricted_max_cropland_fraction_NAto0 <-
classify(r_SIbased_restricted_max_cropland_fraction, cbind(NA,0), filename =
here("Data", "Intermediate_input", "Fraction_of_cropland_max_when_SI_ge_threshold_NAto0.tif"),
overwrite = T)
# alternative function
# f_fraction_agrland_max_i <- function(i) {
#   r_SIbased_restricted_max_cropland_fraction_i <-
#   ifel(r_SIbased_unrestricted_cropland_fraction[[i]] > r_fraction_gl_cl_total_0toNA,
#        r_fraction_gl_cl_total_0toNA,
#        r_SIbased_unrestricted_cropland_fraction[[i]])
#   return(r_SIbased_restricted_max_cropland_fraction_i)
# }
#
# r_SIbased_restricted_max_cropland_fraction_i <- lapply(threshold_values, f_fraction_agrland_max_i)
# names(r_SIbased_restricted_max_cropland_fraction_i) <- paste0("MaxFracOfCellOvr", threshold_values)
r_SIbased_unrestricted_cropland_fraction[[10]] %>% plot()
r_SIbased_restricted_max_cropland_fraction[[10]] %>% plot()
r_SIbased_unrestricted_cropland_fraction[[75]] %>% plot()
r_SIbased_restricted_max_cropland_fraction[[75]] %>% plot()
# ---------------------------------------- HECTARES
# Calculate how much this potential cropland area would be in hectares
# saadaanko laskettua summa joka eri luokalle? Eli kuinka paljon voisi olla sellaista croplandia, jonka SI on 10, kuinka paljon sellaista jonka SI 20 jne
# cellsize with one layer
r_SIbased_restricted_max_cropland_ha_perpix <-
r_SIbased_restricted_max_cropland_fraction *
cellSize(r_SIbased_restricted_max_cropland_fraction[[1]], unit = "ha") # Cellsize constant
writeRaster(r_SIbased_restricted_max_cropland_ha_perpix, filename =
here("Data", "Intermediate_input","max_amount_of_cropland_therecouldbe_whenSIgeThreshold_ha_perpix.tif"),
overwrite = T)
r_SIbased_restricted_max_cropland_ha_perpix_NAto0 <-
classify(r_SIbased_restricted_max_cropland_ha_perpix, cbind(NA,0), filename =
here("Data", "Intermediate_input",
"max_amount_of_cropland_therecouldbe_whenSIgeThreshold_ha_perpix_NAto0.tif"),
overwrite = T)
# Example demonstrating the output of the function f_limit_agrland
testiext <- ext(26.7, 26.9, 61.6, 63.6)
#testiext <- ext(26.7, 26.9, 51.6, 53.6) # use this if you want to see what happens when there is more land based on SI
ex_tibble <- tibble(
SIbased_unrestricted_cropland_ha_perpix = (crop(r_SIbased_unrestricted_cropland_ha_perpix[[10]], testiext) %>% values() %>% as.numeric()),
glcl_haPerpix = (crop((r_fraction_gl_cl_total * cellSize(r_fraction_gl_cl_total, unit = "ha")), testiext) %>% values() %>% as.numeric()),
SIbased_restricted_cropland_ha_perpix = (crop(r_SIbased_restricted_max_cropland_ha_perpix[[10]], testiext) %>% values() %>% as.numeric()))
ex_tibble
# Calculate how much more cropland there could be in cells (croplands already use a lot of very suitable  land). Thus cropland area could be expanded by this many hectares at most (per pixel)
r_potential_cropland_expansion_ha_perpix  <-
r_SIbased_restricted_max_cropland_ha_perpix_NAto0  - r_physical_areas_crops_sum_ha_perpix_NAto0
# Practicalities ----------------------------------- change to native pipe!
# !!!! numeroi scriptit lopuksi: missä järjestyksessä tulee ajaa
# !!! kehittele funktio, joka laskee 99% quantilen kullekin layerille ja trimmaa rasteria sen mukaan
# if (!dir.exists("Data")){ dir.create("Data") }
# if (!dir.exists("Figures")){ dir.create("Figures") } # modify and add to packages etc
# if (!dir.exists("Data/Input")){ dir.create("Data/Input") }
# if (!dir.exists("Data/Intermediate_input")){ dir.create("Data/Intermediate_input") }
# if (!dir.exists("Data/Output")){ dir.create("Data/Output") }
# Packages etc
# install.packages('terra', repos='https://rspatial.r-universe.dev')
# packages <- c("tidyverse", "raster","gdalUtils", "scico",
#               "sf", "terra", "data.table","here", "tictoc",
#               "easypackages")
# not_installed <- packages[!(packages %in% installed.packages()[,"Package"])]
# if(length(not_installed)){install.packages(not_installed)}
library(tidyverse); library(raster); library(terra); library(sf)
library(scico); library(tmap); library(data.table)
library(here); library(tictoc); library(rmapshaper)
library(PolyTrend); library(countrycode);library(readxl)
library(broom); library(tidyr)
# options, mainly for terra package
#terraOptions(tempdir= here("Temp_R"))
#terraOptions()
# timestep
timestep_2000_2015 <- 2000:2015 # !! begins in 2000
timestep_2000_2020 <- 2000:2020
timestep_2001_2015 <- 2001:2015 # is this even needed?
timestep_2001_2020 <- 2001:2020
timestep_climnorm <- 1991:2020
template_rast_5arcmin <- rast(nrows=2160, ncols=4320,
crs = "EPSG:4326")
e <- ext(-180, 180, -90, 90)
# Polygons
adm_10m <- here("Data", "Input", "ne_10m_admin_0_countries.shp") |>
read_sf()
Finland_geom <- adm_10m %>% filter(ADMIN == "Finland") %>% dplyr::select(ADMIN) |>
as("Spatial") |>   vect()
#Finland_ext <- ext(21, 31.5, 60, 70)
# -------------------------------------------------------- create country raster
# adm10_simple <- ms_simplify(adm_10m) #  203 row -- was 258
#
# #change adm10 iso codes to fao codes
# adm10_simple_faoadded <- adm10_simple %>%
#   dplyr::select(ADMIN, NAME, SOVEREIGNT, ISO_A3_EH, REGION_UN) %>%
#   as.data.frame() %>%
#   st_drop_geometry()
#
# adm10_simple_faoadded <- adm10_simple_faoadded %>%
#   mutate(fao_from_iso3eh = countrycode(.$ISO_A3_EH, origin = "iso3c", destination = "fao"),
#          # find fao code also using name of sovereignts (combine these cols later to get match)
#          fao_from_SOVEREIGNT = countrycode(.$SOVEREIGNT, origin = "country.name",  destination = "fao"))
# ## warns that some are missing. However, either fao_from_iso3eh or fao_from_SOVEREIGNT includes most
#
# ## give Somaliland FAO code of Somalia
# adm10_simple_faoadded <- adm10_simple_faoadded %>%
#   rows_update(., tibble(
#     SOVEREIGNT = "Somaliland",
#     fao_from_SOVEREIGNT = (filter(adm10_simple_faoadded, SOVEREIGNT == "Somalia") %>%
#                              pull(fao_from_SOVEREIGNT))))
#
# ## combine cols fao_from_iso3eh and fao_from_SOVEREIGNT.
# ## If any of the columns has value, this value will be the FAO_ID
# adm10_simple_faoadded <- adm10_simple_faoadded %>%
#   mutate(FAO_ID = coalesce(fao_from_iso3eh, fao_from_SOVEREIGNT)) %>%
#   filter(SOVEREIGNT != "Antarctica")  ## drop antarctica
#
#
#
# adm10_simple_faoadded <- st_as_sf(adm10_simple_faoadded)
# # save for intermediate use
# st_write(adm10_simple_faoadded,
#          here("Data", "Intermediate_input", "adm10_simple_faoadded.gpkg"))
## to be bit faster save and read this file
# st_write(adm10_simple_faoadded, here("Data", "Intermediate_input", "adm10_simple_faoadded.gpkg"))
adm10_simple_faoadded <-
here("Data", "Intermediate_input", "adm10_simple_faoadded.gpkg") %>%
st_read()
## convert to raster
cntry_raster <- rasterize(vect(adm10_simple_faoadded),
template_rast_5arcmin, field = "FAO_ID")
#plot(cntry_raster, main = "Antarctica neede or not?")
## convert to rob
adm10_simple_faoadded_rob <-  adm10_simple_faoadded %>%
st_transform(., crs = "ESRI:54030")
# -------------------------------------------------------- not sure which data to use for countries
# --------------------------------------------------------
# admin borders originally created by Vili
# possible to derive from adm10m using e.g package "countryname"
# adm0_vili <-  here("Data", "Input", "adm0_polygons_025dgr.shp") %>%
#   read_sf() %>%
#   dplyr::select(ADMIN, ISO_3166_1, FAO_ID, NAME)
#
# adm0_vili_vecto <- adm0_vili %>% as("Spatial") %>% vect() # 168 unique
#
# #
#
#
# # combine adm10m data with fao id
# df_adm10m <- as.data.frame(adm_10m) %>%
#   dplyr::select(ADMIN, NAME, geometry)
# df_adm0_vili <- as.data.frame(adm0_vili)
#
# # join. We want to preserve countries of df_adm0_vili but add more precise geometries
# df_adm_10m_fao_id <-
#   left_join(df_adm0_vili,
#             df_adm10m, by = c("ADMIN", "NAME" )) %>% # 176 obs.
#   # Combined by name as did not find country codes
#   dplyr::select(ADMIN, NAME, ISO_3166_1, FAO_ID,  geometry.y) %>%
#   rename(geometry = geometry.y)
# head(df_adm_10m_fao_id)
#
# # df_adm0_vili %>% filter(ADMIN == "Finland") %>% head()
# # df_adm_10m_fao_id %>% filter(ADMIN == "Finland") %>% head()
#
#
#
# # adm_10m_fao_id_simple <- st_as_sf(df_adm_10m_fao_id) %>%
# #   ms_simplify()
# adm_10m_fao_id_simple_rob <- adm_10m_fao_id_simple %>%
#   st_transform(., crs = "ESRI:54030")
# # ---------------------------------------------------------------
#
#
# cntry_raster <- rasterize(vect(adm_10m_fao_id_simple),
#                           template_rast_5arcmin, field = "FAO_ID")
# --------------------------------------------------------
# --------------------------------------------------------
## regions
reg <- here("Data", "Input", "reg_mollw.gpkg") |>  st_read()
reg_rob <- st_transform(reg, crs = "ESRI:54030")
reg_wgs <- st_transform(reg, crs = "EPSG:4326")
reg_wgs_vect <- vect(as(reg_wgs, "Spatial"))
#
# reg_rob <- reg_rob |>
#   mutate(subregion = c("Australia and Oceania", "Central America",
#                        "East Asia", "Eastern Europe and Central Asia",
#                        "Ice", "South Asia", "South America", "Middle East",
#                        "Sub-Saharan Africa", "North Africa", "North America",
#                        "Southeast Asia", "Western Europe")) #|>   filter(subregion != "Ice") # maybe not needed ## it is needed for figs
#
#
#
#
# # simplify only for plotting
# reg_rob_simple <- ms_simplify(reg_rob) # Remove ice or not?
# st_write(reg_rob_simple, here("Data", "Intermediate_input", "reg_rob_simple.gpkg"))
reg_rob_simple <- here("Data", "Intermediate_input", "reg_rob_simple.gpkg") %>% st_read()
## function for cropping and maskin
crop_and_mask <- function(r_data, df_cropmask_polygon){
r_data |>
crop(df_cropmask_polygon) |>
mask(df_cropmask_polygon)
}
## function for plotting
create_index_map <- function(r_index, index_label,index_main_title,
colorpal, breakvals,
breaknames = NULL,
color_midpoint = NULL, tocrs = NA){
if (!is.na(tocrs)){
r_index <- project(r_index, tocrs, mask = TRUE)
}
index_map <- tm_shape(r_index) +
tm_raster(palette = colorpal, # try style = "fixed",
breaks = breakvals,
labels = breaknames,
title = index_label,
midpoint = color_midpoint,
legend.is.portrait = FALSE) + # added 9.8.22
#  legend.reverse = TRUE) + # deleted 9.8.22
tm_layout(main.title = index_main_title,
main.title.position = "center",
main.title.size = 1,
legend.bg.color = TRUE,
legend.outside = TRUE,
legend.title.size = 1,
legend.text.size = 1,
legend.outside.size = 0.2,
legend.outside.position = "bottom", # added 9,8
frame = FALSE)+
tm_shape(adm10_simple_faoadded_rob) + # was reg_rob_simple
tm_borders(col = NA,  lwd = 0.5)  # lwd was 0.33, col was "grey30",
return (index_map)
}
## plotting without contry borders (reg instead)
create_index_map_no_cntry <- function(r_index, index_label,index_main_title,
colorpal, breakvals,
breaknames = NULL,
color_midpoint = NULL, tocrs = NA){
if (!is.na(tocrs)){
r_index <- project(r_index, tocrs, mask = TRUE)
}
index_map <- tm_shape(r_index) +
tm_raster(palette = colorpal, # try style = "fixed",
breaks = breakvals,
labels = breaknames,
title = index_label,
midpoint = color_midpoint,
legend.is.portrait = FALSE) + # added 9.8.22
#  legend.reverse = TRUE) + # deleted 9.8.22
tm_layout(main.title = index_main_title,
main.title.position = "center",
main.title.size = 1,
legend.bg.color = TRUE,
legend.outside = TRUE,
legend.title.size = 1,
legend.text.size = 1,
legend.outside.size = 0.2,
legend.outside.position = "bottom", # added 9,8
frame = FALSE)+
tm_shape(reg_rob_simple  ) +
tm_borders(col = NA,  lwd = 0.5)  # lwd was 0.33, col was "grey30",
return (index_map)
}
# Function to remove outliers. Only needed when calculating global sums
f_raster_without_outliers <- function(myraster_layer) {
# Calculate quantiles for both 0.01 and 0.99
quantiles <- quantile(values(myraster_layer), probs = c(0.01, 0.99), na.rm = T)
# Define classification rules with "from-to-becomes" structure
rcl_outliers <- matrix(c(-Inf, quantiles[1], quantiles[1],
quantiles[2], Inf, quantiles[2]), ncol = 3, byrow = T)
# Classify raster values according to rules, with include.lowest and right set
myraster_new <- classify(myraster_layer, rcl_outliers, include.lowest = TRUE, right = NA)
return(myraster_new)
}
f_global_sum_without_outliers <- function(myraster_layer) {
out_values <- quantile(values(myraster_layer), probs = 0.99, na.rm = T)
myraster_new <- myraster_layer
myraster_new[myraster_new > out_values] <- NA
totsum <- global(myraster_new, fun = "sum", na.rm = T)
return(totsum)
}
land_mask <- ifel(cntry_raster > 0, 1, NA)
plot(land_mask) # plot to get rid of error
# Get intermediate data
# ---------------------------------------------------------------- crops
# Crop production areas
r_physical_areas_crops_sum_ha_perpix <-
here("Data", "Intermediate_input","r_physical_areas_crops_sum_ha_perpix.tif") %>%
rast()
# Crop total yields
r_global_production_crops_sum_kg_ha <-
here("Data", "Intermediate_input","r_global_production_crops_sum_kg_ha.tif") %>%
rast()
# Crop protein and energy
r_prot_allcrops_sum_mt_perpix <- here("Data", "Intermediate_input","protein_production_27crops_sum_mt_perpix.tif") %>%
rast()
r_prot_allcrops_sum_kg_ha <- here("Data", "Intermediate_input","protein_production_27crops_sum_kg_ha.tif") %>%
rast()
# ---------------------------------------------------------------- livestock
# Livestock protein and energy
r_protein_from_065xAGB_kg_perpix <- here("Data", "Intermediate_input","r_protein_from_065xAGB_kg_perpix.tif") %>% rast()
r_protein_from_065xAGB_kg_ha <- here("Data", "Intermediate_input","r_protein_from_065xAGB_kg_ha.tif") %>% rast()
r_kcal_from_065xAGB_MM_ha <- here("Data", "Intermediate_input","r_kcal_from_065xAGB_MM_ha.tif") %>%  rast()
r_kcal_from_065xAGB_MM_perpix <-
here("Data", "Intermediate_input","r_kcal_from_065xAGB_MM_perpix.tif") %>%
rast()
# ------------------------------------------------------------------- fractions
# Fraction of crops in a cell
r_fraction_cl <-
here("Data", "Intermediate_input","r_fraction_cl_with_27_spamcrops.tif") %>%
rast()
r_fraction_cl[r_fraction_cl >1] <- 1
r_fraction_cl_0toNA <- classify(r_fraction_cl, cbind(0,NA))
r_fraction_cl_NAto0 <- classify(r_fraction_cl, cbind(NA,0))
r_fraction_gl <-
here("Data", "Input", "from_harddrive",
"fraction_of_cell_that_is_hyde_grazingland2010_0toNA.tif") %>%   #### changed
rast()
r_fraction_gl[r_fraction_gl >1] <- 1
r_fraction_gl_0toNA <- classify(r_fraction_gl, cbind(0,NA))
r_fraction_gl_NAto0 <- classify(r_fraction_gl, cbind(NA,0))
r_fraction_gl_cl_total <- r_fraction_gl_NAto0 + r_fraction_cl_NAto0 # cannot be over 1!
r_fraction_gl_cl_total[r_fraction_gl_cl_total>1] <- 1
r_fraction_gl_cl_total_NAto0 <- classify(r_fraction_gl_cl_total, cbind(NA,0)) # totally same as above!
r_fraction_gl_cl_total_0toNA <- classify(r_fraction_gl_cl_total, cbind(0,NA))
# --------------------------------------------------------- Suitability indices
SI_5arcmin <-
here("Data", "Input", "Zabel22_SI",
"SI_5arcmin_overall_suitability_subset1to17_hist1980_2009_current_irr_areas_applied.tif") %>%
rast()
# AGB protein per ha ---------- should this be yield instead? --> if works use protein
r_protein_from_065xAGB_kg_ha <- # or this should represent average herd strucutres
here("Data", "Intermediate_input","r_protein_from_065xAGB_kg_ha.tif") %>%
rast()
SI_grasses_5arcmin <-
here("Data", "Input", "from_harddrive",
"SI_plants19_20_21_5arcmin.tif") %>%
rast()
# test with current herd structures
r_protein_and_SI <- c(r_protein_from_065xAGB_kg_ha$current_herd_str,
SI_grasses_5arcmin)
all_countries <- adm10_simple_faoadded
# tehdään rasteri kullekin eri maalle (tarvitaan df arvot reg varten) --- tässä listana maapolygonit
country_sf_list <- all_countries %>%
mutate(country_sf_list = map(ADMIN, ~filter(adm10_simple_faoadded, ADMIN == .x))) %>%
pull(country_sf_list)
country_sf_list[[53]] %>% plot() # FI
# tämän listan perustella voidaan maskata rasteri r_protein_and_SI kullekin maalle
country_raster_list <- map(country_sf_list, ~crop_and_mask(r_protein_and_SI, .x))
country_raster_list[[53]] %>% plot() # FI
# Muunnetaan country_raster_list dataframeksi
# löytyy koordinaatit sekä crop_protein_kg_ha  ja overall_suitability data joka maalle
country_df_list <- map(country_raster_list, ~as.data.frame(.x, xy = T) %>% as_tibble())
country_df_list[[53]] # suomen koordinaatit, current_herd_str_protein_kg_ha  ja SI for 3 grasses
# etsitään datasta outlierit joka maalle (taas lista)
outlier_level_list <- map_dbl(country_df_list, ~quantile(.x$current_herd_str,
probs = 0.95, na.rm = T)) # 95 or 99?
outlier_level_list[[53]]
# Filtteröidään data niin, että outlierit poistettu. Poistetaan myös x ja y
country_df_filtered_list <-
map2(country_df_list,
outlier_level_list, ~.x %>% filter(current_herd_str <= .y) %>% # not sure if I should add !is.na(overall_suitability) --> varmaan jos SI == 0 nii myös pois
dplyr::select(-c(x, y)))
country_df_filtered_list[[53]] # tässä data regressiota varten
# tehdään regressio tästä filtteröidystä datasta -- käytetään safe funktiota
# Wrapper function for linear regression
fit_lm_possibly <- function(data) {
model_output <-
lm(current_herd_str ~ plantspecific_suitability_19 + plantspecific_suitability_20 +
plantspecific_suitability_21, data = data)
model_coef <- model_output %>%
broom::tidy() %>%
dplyr::select(term, estimate,  p.value) %>%
pivot_wider(., names_from = term, values_from = c(estimate, p.value))
model_stats <- model_output %>%
broom::glance()
# Combine model_coef and model_stats into a single row data frame
result <- model_coef %>%
mutate(r.squared = model_stats$r.squared,
adj.r.squared = model_stats$adj.r.squared,
AIC = model_stats$AIC,
BIC = model_stats$BIC,
nobs = model_stats$nobs,
sigma = model_stats$sigma,
statistic = model_stats$statistic,
p.value_Ftest = model_stats$p.value)
#
return(result)
}
# Safe version of the linear regression function
fit_lm_safe <- purrr::possibly(fit_lm_possibly, otherwise = NULL)
model_list <- map(country_df_filtered_list, fit_lm_safe)
model_list[[53]] # suomen tulos, mutta yhdellä rivillä
# yhdistetään nested country_df_filtered_list polygonien kanssa
all_countries <- all_countries %>%
mutate(country_df_filtered_list = country_df_filtered_list,
model_list = model_list)
# clean
all_countries_cleaned <- all_countries %>%
dplyr::select(ADMIN, ISO_A3_EH, REGION_UN, geom, model_list)
all_countries_cleaned <- all_countries_cleaned %>%
mutate(model_list = map(model_list, ~ as_tibble(.x))) %>%
unnest(cols = model_list, keep_empty = T)
#View(all_countries_cleaned)
summary(all_countries_cleaned$p.value_plantspecific_suitability_19)
summary(all_countries_cleaned$p.value_plantspecific_suitability_20)
summary(all_countries_cleaned$p.value_plantspecific_suitability_21)
filter(all_countries_cleaned, p.value_plantspecific_suitability_19 < 0.05) %>%
dplyr::select(adj.r.squared) %>% summary() # almost same for all of these grass species
View(all_countries_cleaned)
names(all_countries_cleaned)
filter(all_countries_cleaned, p.value_Ftest < 0.05) %>%
dplyr::select(adj.r.squared) %>% summary() # almost same for all of these grass species
kok <- country_df_filtered_list[[53]]
finland_agbprot <- lm(current_herd_str ~ plantspecific_suitability_19 +
plantspecific_suitability_20 + plantspecific_suitability_21, data = kok)
summary(finland_agbprot) # F-statistic:  12.88 p-value: 1.43e-07
broom::tidy(finland_agbprot)
broom::glance(finland_agbprot)
m <- broom::tidy(finland_agbprot) %>%
dplyr::select(-c(std.error, statistic))
m_wide <- pivot_wider(m, names_from = term, values_from = c(estimate, p.value))
m_wide
View(m)
plot(SI_grasses_5arcmin)
model_significant <- all_countries_cleaned %>% filter(pvalue_suitability < 0.05)
model_significant <- all_countries_cleaned %>% filter(p.value_Ftest < 0.05)
# tehdään regressio tästä filtteröidystä datasta -- käytetään safe funktiota
# Wrapper function for linear regression
fit_lm_possibly <- function(data) {
model_output <-
lm(current_herd_str ~  plantspecific_suitability_20 +
plantspecific_suitability_21, data = data)
model_coef <- model_output %>%
broom::tidy() %>%
dplyr::select(term, estimate,  p.value) %>%
pivot_wider(., names_from = term, values_from = c(estimate, p.value))
model_stats <- model_output %>%
broom::glance()
# Combine model_coef and model_stats into a single row data frame
result <- model_coef %>%
mutate(r.squared = model_stats$r.squared, # these from model stats
adj.r.squared = model_stats$adj.r.squared,
AIC = model_stats$AIC,
BIC = model_stats$BIC,
nobs = model_stats$nobs,
sigma = model_stats$sigma,
statistic = model_stats$statistic,
p.value_Ftest = model_stats$p.value)
#
return(result)
}
# Safe version of the linear regression function
fit_lm_safe <- purrr::possibly(fit_lm_possibly, otherwise = NULL)
model_list <- map(country_df_filtered_list, fit_lm_safe)
model_list[[53]] # suomen tulos, mutta yhdellä rivillä
# yhdistetään nested country_df_filtered_list polygonien kanssa
all_countries <- all_countries %>%
