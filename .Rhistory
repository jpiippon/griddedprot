colorpal, breakvals,
breaknames = NULL,
color_midpoint = NULL, tocrs = NA){
if (!is.na(tocrs)){
r_index <- project(r_index, tocrs, mask = TRUE)
}
index_map <- tm_shape(r_index) +
tm_raster(palette = colorpal, # try style = "fixed",
breaks = breakvals,
labels = breaknames,
title = index_label,
midpoint = color_midpoint,
legend.is.portrait = FALSE) + # added 9.8.22
#  legend.reverse = TRUE) + # deleted 9.8.22
tm_layout(main.title = index_main_title,
main.title.position = "center",
main.title.size = 1,
legend.bg.color = TRUE,
legend.outside = TRUE,
legend.title.size = 1,
legend.text.size = 1,
legend.outside.size = 0.2,
legend.outside.position = "bottom", # added 9,8
frame = FALSE)+
tm_shape(reg_rob_simple  ) +
tm_borders(col = NA,  lwd = 0.5)  # lwd was 0.33, col was "grey30",
return (index_map)
}
# Function to remove outliers. Only needed when calculating global sums
f_raster_without_outliers <- function(myraster_layer) {
# Calculate quantiles for both 0.01 and 0.99
quantiles <- quantile(values(myraster_layer), probs = c(0.01, 0.99), na.rm = T)
# Define classification rules with "from-to-becomes" structure
rcl_outliers <- matrix(c(-Inf, quantiles[1], quantiles[1],
quantiles[2], Inf, quantiles[2]), ncol = 3, byrow = T)
# Classify raster values according to rules, with include.lowest and right set
myraster_new <- classify(myraster_layer, rcl_outliers, include.lowest = TRUE, right = NA)
return(myraster_new)
}
f_global_sum_without_outliers <- function(myraster_layer) {
out_values <- quantile(values(myraster_layer), probs = 0.99, na.rm = T)
myraster_new <- myraster_layer
myraster_new[myraster_new > out_values] <- NA
totsum <- global(myraster_new, fun = "sum", na.rm = T)
return(totsum)
}
land_mask <- ifel(cntry_raster > 0, 1, NA)
plot(land_mask) # plot to get rid of error
r_agb_5y_med_in_hyde_gl_kg_ha <-
here("Data", "Input", "from_harddrive",
"5y_medAGB_withIGPB6to10or16_in_hydeareas_kg_ha_5arcmin.tif") %>%
rast()
r_agb_fi <- crop_and_mask(r_agb_5y_med_in_hyde_gl_kg_ha, Finland_geom)
r_agb_fi %>% qtm()
r_agb_fi %>% qtm()
summary(r_agb_5y_med_in_hyde_gl_kg_ha)
summary(r_agb_fi)
plot(r_agb_fi)
18000*0.3
600/5000
# Practicalities ----------------------------------- change to native pipe!
# !!!! numeroi scriptit lopuksi: missä järjestyksessä tulee ajaa
# !!! kehittele funktio, joka laskee 99% quantilen kullekin layerille ja trimmaa rasteria sen mukaan
# if (!dir.exists("Data")){ dir.create("Data") }
# if (!dir.exists("Figures")){ dir.create("Figures") } # modify and add to packages etc
# if (!dir.exists("Data/Input")){ dir.create("Data/Input") }
# if (!dir.exists("Data/Intermediate_input")){ dir.create("Data/Intermediate_input") }
# if (!dir.exists("Data/Output")){ dir.create("Data/Output") }
# Packages etc
# install.packages('terra', repos='https://rspatial.r-universe.dev')
# packages <- c("tidyverse", "raster","gdalUtils", "scico",
#               "sf", "terra", "data.table","here", "tictoc",
#               "easypackages")
# not_installed <- packages[!(packages %in% installed.packages()[,"Package"])]
# if(length(not_installed)){install.packages(not_installed)}
library(tidyverse); library(raster); library(terra); library(sf)
library(scico); library(tmap); library(data.table)
library(here); library(tictoc); library(rmapshaper)
library(PolyTrend); library(countrycode);library(readxl)
library(broom); library(tidyr)
# options, mainly for terra package
#terraOptions(tempdir= here("Temp_R"))
#terraOptions()
# timestep
timestep_2000_2015 <- 2000:2015 # !! begins in 2000
timestep_2000_2020 <- 2000:2020
timestep_2001_2015 <- 2001:2015 # is this even needed?
timestep_2001_2020 <- 2001:2020
timestep_climnorm <- 1991:2020
template_rast_5arcmin <- rast(nrows=2160, ncols=4320,
crs = "EPSG:4326")
e <- ext(-180, 180, -90, 90)
# Polygons
adm_10m <- here("Data", "Input", "ne_10m_admin_0_countries.shp") |>
read_sf()
Finland_geom <- adm_10m %>% filter(ADMIN == "Finland") %>% dplyr::select(ADMIN) |>
as("Spatial") |>   vect()
#Finland_ext <- ext(21, 31.5, 60, 70)
# -------------------------------------------------------- create country raster
# adm10_simple <- ms_simplify(adm_10m) #  203 row -- was 258
#
# #change adm10 iso codes to fao codes
# adm10_simple_faoadded <- adm10_simple %>%
#   dplyr::select(ADMIN, NAME, SOVEREIGNT, ISO_A3_EH, REGION_UN) %>%
#   as.data.frame() %>%
#   st_drop_geometry()
#
# adm10_simple_faoadded <- adm10_simple_faoadded %>%
#   mutate(fao_from_iso3eh = countrycode(.$ISO_A3_EH, origin = "iso3c", destination = "fao"),
#          # find fao code also using name of sovereignts (combine these cols later to get match)
#          fao_from_SOVEREIGNT = countrycode(.$SOVEREIGNT, origin = "country.name",  destination = "fao"))
# ## warns that some are missing. However, either fao_from_iso3eh or fao_from_SOVEREIGNT includes most
#
# ## give Somaliland FAO code of Somalia
# adm10_simple_faoadded <- adm10_simple_faoadded %>%
#   rows_update(., tibble(
#     SOVEREIGNT = "Somaliland",
#     fao_from_SOVEREIGNT = (filter(adm10_simple_faoadded, SOVEREIGNT == "Somalia") %>%
#                              pull(fao_from_SOVEREIGNT))))
#
# ## combine cols fao_from_iso3eh and fao_from_SOVEREIGNT.
# ## If any of the columns has value, this value will be the FAO_ID
# adm10_simple_faoadded <- adm10_simple_faoadded %>%
#   mutate(FAO_ID = coalesce(fao_from_iso3eh, fao_from_SOVEREIGNT)) %>%
#   filter(SOVEREIGNT != "Antarctica")  ## drop antarctica
#
#
#
# adm10_simple_faoadded <- st_as_sf(adm10_simple_faoadded)
# # save for intermediate use
# st_write(adm10_simple_faoadded,
#          here("Data", "Intermediate_input", "adm10_simple_faoadded.gpkg"))
## to be bit faster save and read this file
# st_write(adm10_simple_faoadded, here("Data", "Intermediate_input", "adm10_simple_faoadded.gpkg"))
adm10_simple_faoadded <-
here("Data", "Intermediate_input", "adm10_simple_faoadded.gpkg") %>%
st_read()
## convert to raster
cntry_raster <- rasterize(vect(adm10_simple_faoadded),
template_rast_5arcmin, field = "FAO_ID")
#plot(cntry_raster, main = "Antarctica neede or not?")
## convert to rob
adm10_simple_faoadded_rob <-  adm10_simple_faoadded %>%
st_transform(., crs = "ESRI:54030")
# -------------------------------------------------------- not sure which data to use for countries
# --------------------------------------------------------
# admin borders originally created by Vili
# possible to derive from adm10m using e.g package "countryname"
# adm0_vili <-  here("Data", "Input", "adm0_polygons_025dgr.shp") %>%
#   read_sf() %>%
#   dplyr::select(ADMIN, ISO_3166_1, FAO_ID, NAME)
#
# adm0_vili_vecto <- adm0_vili %>% as("Spatial") %>% vect() # 168 unique
#
# #
#
#
# # combine adm10m data with fao id
# df_adm10m <- as.data.frame(adm_10m) %>%
#   dplyr::select(ADMIN, NAME, geometry)
# df_adm0_vili <- as.data.frame(adm0_vili)
#
# # join. We want to preserve countries of df_adm0_vili but add more precise geometries
# df_adm_10m_fao_id <-
#   left_join(df_adm0_vili,
#             df_adm10m, by = c("ADMIN", "NAME" )) %>% # 176 obs.
#   # Combined by name as did not find country codes
#   dplyr::select(ADMIN, NAME, ISO_3166_1, FAO_ID,  geometry.y) %>%
#   rename(geometry = geometry.y)
# head(df_adm_10m_fao_id)
#
# # df_adm0_vili %>% filter(ADMIN == "Finland") %>% head()
# # df_adm_10m_fao_id %>% filter(ADMIN == "Finland") %>% head()
#
#
#
# # adm_10m_fao_id_simple <- st_as_sf(df_adm_10m_fao_id) %>%
# #   ms_simplify()
# adm_10m_fao_id_simple_rob <- adm_10m_fao_id_simple %>%
#   st_transform(., crs = "ESRI:54030")
# # ---------------------------------------------------------------
#
#
# cntry_raster <- rasterize(vect(adm_10m_fao_id_simple),
#                           template_rast_5arcmin, field = "FAO_ID")
# --------------------------------------------------------
# --------------------------------------------------------
## regions
reg <- here("Data", "Input", "reg_mollw.gpkg") |>  st_read()
reg_rob <- st_transform(reg, crs = "ESRI:54030")
reg_wgs <- st_transform(reg, crs = "EPSG:4326")
reg_wgs_vect <- vect(as(reg_wgs, "Spatial"))
#
# reg_rob <- reg_rob |>
#   mutate(subregion = c("Australia and Oceania", "Central America",
#                        "East Asia", "Eastern Europe and Central Asia",
#                        "Ice", "South Asia", "South America", "Middle East",
#                        "Sub-Saharan Africa", "North Africa", "North America",
#                        "Southeast Asia", "Western Europe")) #|>   filter(subregion != "Ice") # maybe not needed ## it is needed for figs
#
#
#
#
# # simplify only for plotting
# reg_rob_simple <- ms_simplify(reg_rob) # Remove ice or not?
# st_write(reg_rob_simple, here("Data", "Intermediate_input", "reg_rob_simple.gpkg"))
reg_rob_simple <- here("Data", "Intermediate_input", "reg_rob_simple.gpkg") %>% st_read()
## function for cropping and maskin
crop_and_mask <- function(r_data, df_cropmask_polygon){
r_data |>
crop(df_cropmask_polygon) |>
mask(df_cropmask_polygon)
}
## function for plotting
create_index_map <- function(r_index, index_label,index_main_title,
colorpal, breakvals,
breaknames = NULL,
color_midpoint = NULL, tocrs = NA){
if (!is.na(tocrs)){
r_index <- project(r_index, tocrs, mask = TRUE)
}
index_map <- tm_shape(r_index) +
tm_raster(palette = colorpal, # try style = "fixed",
breaks = breakvals,
labels = breaknames,
title = index_label,
midpoint = color_midpoint,
legend.is.portrait = FALSE) + # added 9.8.22
#  legend.reverse = TRUE) + # deleted 9.8.22
tm_layout(main.title = index_main_title,
main.title.position = "center",
main.title.size = 1,
legend.bg.color = TRUE,
legend.outside = TRUE,
legend.title.size = 1,
legend.text.size = 1,
legend.outside.size = 0.2,
legend.outside.position = "bottom", # added 9,8
frame = FALSE)+
tm_shape(adm10_simple_faoadded_rob) + # was reg_rob_simple
tm_borders(col = NA,  lwd = 0.5)  # lwd was 0.33, col was "grey30",
return (index_map)
}
## plotting without contry borders (reg instead)
create_index_map_no_cntry <- function(r_index, index_label,index_main_title,
colorpal, breakvals,
breaknames = NULL,
color_midpoint = NULL, tocrs = NA){
if (!is.na(tocrs)){
r_index <- project(r_index, tocrs, mask = TRUE)
}
index_map <- tm_shape(r_index) +
tm_raster(palette = colorpal, # try style = "fixed",
breaks = breakvals,
labels = breaknames,
title = index_label,
midpoint = color_midpoint,
legend.is.portrait = FALSE) + # added 9.8.22
#  legend.reverse = TRUE) + # deleted 9.8.22
tm_layout(main.title = index_main_title,
main.title.position = "center",
main.title.size = 1,
legend.bg.color = TRUE,
legend.outside = TRUE,
legend.title.size = 1,
legend.text.size = 1,
legend.outside.size = 0.2,
legend.outside.position = "bottom", # added 9,8
frame = FALSE)+
tm_shape(reg_rob_simple  ) +
tm_borders(col = NA,  lwd = 0.5)  # lwd was 0.33, col was "grey30",
return (index_map)
}
# Function to remove outliers. Only needed when calculating global sums
f_raster_without_outliers <- function(myraster_layer) {
# Calculate quantiles for both 0.01 and 0.99
quantiles <- quantile(values(myraster_layer), probs = c(0.01, 0.99), na.rm = T)
# Define classification rules with "from-to-becomes" structure
rcl_outliers <- matrix(c(-Inf, quantiles[1], quantiles[1],
quantiles[2], Inf, quantiles[2]), ncol = 3, byrow = T)
# Classify raster values according to rules, with include.lowest and right set
myraster_new <- classify(myraster_layer, rcl_outliers, include.lowest = TRUE, right = NA)
return(myraster_new)
}
f_global_sum_without_outliers <- function(myraster_layer) {
out_values <- quantile(values(myraster_layer), probs = 0.99, na.rm = T)
myraster_new <- myraster_layer
myraster_new[myraster_new > out_values] <- NA
totsum <- global(myraster_new, fun = "sum", na.rm = T)
return(totsum)
}
land_mask <- ifel(cntry_raster > 0, 1, NA)
plot(land_mask) # plot to get rid of error
plot(cntry_raster) # Error in x$.self$finalize() : attempt to apply non-function
cntry_raster
# ---------------------------------------------------------- FAOSTAT download
foodBalanceSheets_semiraw <-
here("Data", "Input", "faostat", "foodBalanceSheets_E_All_Data_NOFLAG.csv") %>%
read.csv() %>%
dplyr::select(-Element.Code,-Unit ,-c(Y2011:Y2019))
my_elementlist_fao <- c(
"Production",
"Food supply quantity (kg/capita/yr)",
"Food supply (kcal/capita/day)",
"Protein supply quantity (g/capita/day)")
my_itemlist_fao_animals <- c("Meat", "Bovine Meat", "Mutton & Goat Meat")
# ---------------------------------------- FAOSTAT animal protein to kcal
fbs_animals <- foodBalanceSheets_semiraw %>%
filter(Item %in% my_itemlist_fao_animals,
Element %in% my_elementlist_fao)
## pivot wider
fbs_animals_wide <- fbs_animals %>%
pivot_wider(names_from = Element, values_from = Y2010) %>%
rename(prod_1000mt = "Production", # eg numbers in FIN equals Lukestat
supply.KgCapYr = "Food supply quantity (kg/capita/yr)",
supply.KcalCapD = "Food supply (kcal/capita/day)",
prot.gCapD = "Protein supply quantity (g/capita/day)") %>%
## how many kcal do we get from amount of meat containing one kg of protein - required for simple conversion from protein production to energy production
## create variable protein to kcal
mutate(one_kg_prot_to_kcal =  (supply.KcalCapD / prot.gCapD) * 1000,
protein_fraction = (prot.gCapD*365/1000) / supply.KgCapYr) %>% # protein fraction for meat products -- not even needed
dplyr::select(-Item.Code) %>%
mutate_all(function(x) ifelse(is.nan(x) | is.infinite(x), NA, x))  # convert NaN values to NA
# fill empty columns (values 0 or NA) with global averages similardly as done earlier with crops
## ex with Bovine meat. First, find global average for one_kg_prot_to_kcal
# one_kg_prot_to_kcal_bovine <- fbs_animals_wide %>%
#   filter(Item == "Bovine Meat", Area == "World") %>%
#   pull(one_kg_prot_to_kcal)
#
#   ## then replace 0 or NA values with this value
# test_bovine  <- fbs_animals_wide %>%
#   filter(Item == "Bovine Meat") %>%
#   mutate(one_kg_prot_to_kcal =
#            ifelse(is.na(one_kg_prot_to_kcal) | one_kg_prot_to_kcal == 0 , # if one_kg_prot_to_kcal fraction = NA or 0,
#                                    one_kg_prot_to_kcal_bovine, # fill with the global average value
#                                    one_kg_prot_to_kcal))  # otherwise let it just be
# do this with function for all meat items and fill also protein_fraction col if that's needed later
f_fill_missing_nutritient_values_animals<- function(animalcategory) {
## pull one_kg_prot_to_kcal for spesific animal species
one_kg_prot_to_kcal_animalcategory <- fbs_animals_wide %>%
filter(Item == animalcategory, Area == "World") %>%
pull(one_kg_prot_to_kcal)
## pull protein fraction for spesific crop
protein_fraction_animalcategory <- fbs_animals_wide %>%
filter(Item == animalcategory, Area == "World") %>%
pull(protein_fraction)
## fill empty one_kg_prot_to_kcal amd protein_fraction  with global averages
fbs_animals_wide_filled <- fbs_animals_wide %>%
filter(Item == animalcategory) %>%
## fill one_kg_prot_to_kcal column
mutate(one_kg_prot_to_kcal =
ifelse(is.na(one_kg_prot_to_kcal) | one_kg_prot_to_kcal == 0 , # if protein fraction = NA or 0,
one_kg_prot_to_kcal_animalcategory, # fill with the global average value
one_kg_prot_to_kcal)) %>% # otherwise let it just be
## fill protein_fraction column
mutate(protein_fraction =
ifelse(is.na(protein_fraction) | protein_fraction == 0 ,
protein_fraction_animalcategory,
protein_fraction))
return(fbs_animals_wide_filled)
}
# Lapply this for all the animal species  --> returns a list
fbs_animals_wide_filled_list <-
lapply(my_itemlist_fao_animals,
f_fill_missing_nutritient_values_animals)
# next we use bind_rows to make this reasonable looking dataframe
fbs_animals_wide_filled <- bind_rows(fbs_animals_wide_filled_list)
View(fbs_animals_wide_filled)
# ---------------------------------------------------------- FAOSTAT download
## no need to update the data if we use only yr 2010?
foodBalanceSheets_semiraw <-
here("Data", "Input", "faostat", "foodBalanceSheets_E_All_Data_NOFLAG.csv") %>%
read.csv() %>%
dplyr::select(-Element.Code,-Unit ,-c(Y2011:Y2019))
# ---------------------------------------------------------- crops
my_itemlist_fao <- c(  # in mapspam webpage order
"Wheat and products", "Rice and products","Maize and products",
"Barley and products", "Millet and products", "Sorghum and products",
"Cereals, Other", "Potatoes and products", "Sweet potatoes",
"Yams", "Cassava and products", "Roots, Other",
"Beans", "Peas", "Pulses, Other and products",
"Soyabeans","Groundnuts", "Coconuts - Incl Copra",
"Bananas", "Plantains", "Fruits, other", "Vegetables" # categories for SPAM names
)
my_elementlist_fao <- c(
"Production","Food supply quantity (kg/capita/yr)",
"Food supply (kcal/capita/day)", "Protein supply quantity (g/capita/day)"
)
## filter
fbs_crops <- foodBalanceSheets_semiraw  %>%
filter(Item %in% my_itemlist_fao,
Element %in% my_elementlist_fao)
## to wide format. Select only relevant variables
fbs_crops_wide <- fbs_crops %>%
pivot_wider(names_from = Element, values_from = Y2010) %>%
rename(prod_1000mt = "Production",
supply.KgCapYr = "Food supply quantity (kg/capita/yr)",
supply.KcalCapD = "Food supply (kcal/capita/day)",
prot.gCapD = "Protein supply quantity (g/capita/day)")
## add column where item names corresponds to mapsmap names
## see Definitions and standards - Food Balances (2010-) for the classes
## cannot add information for all crops like this -- add SMIL, COWP, PIGE, OPUL, LENT, TROF afterwards
fbs_crops_wide <- fbs_crops_wide %>%
mutate(spamname = case_when(
Item == "Wheat and products" ~ "WHEA",
Item == "Rice and products"  ~ "RICE",
Item == "Barley and products" ~ "BARL",
Item == "Maize and products" ~ "MAIZ",
Item == "Millet and products"  ~ "PMIL",
#    Item == "Millet and products"  ~ "SMIL", # ei toimi koska 2x Millet and products
Item == "Sorghum and products"  ~ "SORG",
Item == "Cereals, Other"   ~ "OCER",
Item == "Potatoes and products" ~ "POTA",
Item == "Sweet potatoes"  ~ "SWPO",
Item == "Yams"  ~ "YAMS",
Item == "Cassava and products"   ~ "CASS",
Item == "Roots, Other"  ~ "ORTS",
Item == "Beans"  ~ "BEAN",
Item == "Pulses, Other and products"  ~ "CHIC",
#    Item == "Pulses, Other and products" ~ "COWP",
#    Item == "Pulses, Other and products" ~ "PIGE",
#    Item == "Pulses, Other and products"  ~ "OPUL",
#    Item == "Pulses, Other and products"  ~ "LENT",
Item == "Soyabeans"  ~ "SOYB",
Item == "Groundnuts"   ~ "GROU",
Item == "Coconuts - Incl Copra"  ~ "CNUT",
Item == "Bananas"  ~ "BANA",
Item == "Plantains"  ~ "PLNT",
Item == "Fruits, other"  ~ "TROF",
#    Item == "Fruits, other"  ~ "TEMF",
Item == "Vegetables"  ~ "VEGE"
))
# could be done with function but was faster like this..
additional_rows <- list(
fbs_crops_wide %>% filter(Item == "Millet and products") %>% mutate(spamname = "SMIL"),
fbs_crops_wide %>% filter(Item == "Pulses, Other and products") %>% mutate(spamname = "COWP"),
fbs_crops_wide %>% filter(Item == "Pulses, Other and products") %>% mutate(spamname = "PIGE"),
fbs_crops_wide %>% filter(Item == "Pulses, Other and products") %>% mutate(spamname = "OPUL"),
fbs_crops_wide %>% filter(Item == "Pulses, Other and products") %>% mutate(spamname = "LENT"),
fbs_crops_wide %>% filter(Item == "Fruits, other") %>% mutate(spamname = "TEMF")
)
fbs_crops_wide <- fbs_crops_wide %>% bind_rows(additional_rows)
mylist_spamnames <- c(
"WHEA", "RICE", "BARL", "MAIZ", "PMIL",
"SMIL","SORG",  "OCER", "CASS", "POTA",
"SWPO", "YAMS", "ORTS", "BEAN", "CHIC",
"COWP", "PIGE", "OPUL", "LENT", "SOYB",
"GROU", "CNUT", "BANA", "PLNT", "TROF",
"TEMF", "VEGE") # 27
# ------------------------- Calculate fraction of protein and kcal in a product (conversion factor)
## protein and kcal
fbs_crops_wide <- fbs_crops_wide %>%
mutate(protein_fraction = (prot.gCapD * 365 / 1000) / supply.KgCapYr,
kcalPerKg = (supply.KcalCapD * 365)/ supply.KgCapYr)  %>%
## remove cases where supply = 0 (cases that yield NA values)
## # also converts NaN to NA
mutate_all(function(x) ifelse(is.nan(x) | is.infinite(x), NA, x))
# ---------------------------------------------------------- Fill empty rows
# Fill empty protein_fraction and kcalPerKg rows with global average values
## example for soy
# prot_frac_soy <- fbs_crops_wide %>%
#   filter(spamname == "SOYB", Area == "World") %>%
#   pull(protein_fraction)
#
# test_soy  <- fbs_crops_wide %>%
#   filter(spamname == "SOYB") %>%
#   mutate(protein_fraction =
#            ifelse(is.na(protein_fraction) | protein_fraction == 0 , # if protein fraction = NA or 0,
#                                    prot_frac_soy, # fill with the global average value
#                                    protein_fraction))  # otherwise let it just be
# Create a function that fills empty values of cols protein_fraction and kcalPerKg
f_fill_missing_nutritient_values_crops <- function(cropname_mapspam) {
## pull protein fraction for spesific crop
protein_fraction_spamcrop <- fbs_crops_wide %>%
filter(spamname == cropname_mapspam, Area == "World") %>%
pull(protein_fraction)
## pull KcalPerKg for spesific crop
KcalPerKg_spamcrop <- fbs_crops_wide %>%
filter(spamname == cropname_mapspam, Area == "World") %>%
pull(kcalPerKg)
## fill empty protein fraction and kcalPerKg with global averages
fbs_crops_wide_filled <- fbs_crops_wide %>%
filter(spamname == cropname_mapspam) %>%
## fill protein_fraction column
mutate(protein_fraction =
ifelse(is.na(protein_fraction) | protein_fraction == 0 , # if protein fraction = NA or 0,
protein_fraction_spamcrop, # fill with the global average value
protein_fraction)) %>% # otherwise let it just be
## fill KcalPerKg column
mutate(kcalPerKg =
ifelse(is.na(kcalPerKg) | kcalPerKg == 0 ,
KcalPerKg_spamcrop,
kcalPerKg))
return(fbs_crops_wide_filled)
}
test1 <- f_fill_missing_nutritient_values_crops("SOYB") # returns a df
# Lapply this for all the crops --> returns a list
fbs_crops_wide_filled_list <-
lapply(mylist_spamnames, f_fill_missing_nutritient_values_crops)
# next we use bind_rows to make this reasonable looking dataframe
fbs_crops_wide_filled <- bind_rows(fbs_crops_wide_filled_list)
fbs_crops_wide_filled$spamname %>% unique()
View(fbs_crops_wide_filled)
0.416/2.4
1/0.18
0.418*0.418
0.2/7
0.9*0.14
0.9/(0.9*0.14)
(0.03*20)/(0.9*0.14)
(0.03*7*20)/(0.9*0.14*7)
(0.03/0.14*20)/(0.9*0.14/0.14)
