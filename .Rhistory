r_fraction_agrland_max_cellsize <-
cellSize(r_fraction_agrland_max$MaxFracOfCellOvr1,
unit = "ha")
r_fraction_agrland_max_ha_perpix <-
r_fraction_agrland_max *
r_fraction_agrland_max_cellsize # Cellsize constant
df_agricultural_land_within_SI_class_mha <-
tibble(
SI_class = threshold_values,
global(r_fraction_agrland_max_ha_perpix, fun = "sum", na.rm = T)/1e6
)
ggplot(df_agricultural_land_within_SI_class_mha, aes(x = SI_class, y = sum)) +
geom_line() +
labs(title = "Agricultural Land Within SI Class (mha)", x = "SI Class", y = "Total Sum (mha)")
which.max(values(r_fraction_agrland_max_ha_perpix[[1]]))
r_fraction_agrland_max_ha_perpix[[1]]
r_fraction_agrland_max[[75]] %>% plot()
r_fraction_agrland_max[[5]] %>% plot()
selected_layers <- seq(10, 100, by = 10)
selected_rasters <- r_SI_class_fraction[[selected_layers]]
selected_rasters1 <- r_fraction_agrland_max[[selected_layers]]
selected_rasters2 <- r_fraction_agrland_max_ha_perpix[[selected_layers]]
plot(selected_rasters, main = "Unrestrcited fraction of suitable land in a cell")
plot(selected_rasters1, main = "Max fraction of agricultural land in a cell")
plot(selected_rasters2, main = "Ha of agricultural land in a cell")
r_fraction_agrland_max_ha_perpix[[96]]
r_fraction_agrland_max_ha_perpix[[1]]
plot(r_fraction_agrland_max_ha_perpix[[96]])
r_physical_areas_crops_sum_ha_perpix_NAto0
r_agrland_max_ha_perpix <- r_fraction_agrland_max_ha_perpix
r_agrland_max_ha_perpix_NAto0 <- classify(r_agrland_max_ha_perpix, cbind(NA,0))
r_agrland_max_ha_perpix_NAto0
# Calculate how much more cropland there could be in cells (croplands already use a lot of very suitable  land)
# Thus cropland area could be expanded by this many hectares at most
r_potential_expansion_of_cl_ha_perpix <-
r_agrland_max_ha_perpix_NAto0  - r_physical_areas_crops_sum_ha_perpix_NAto0
r_potential_expansion_of_cl_ha_perpix
which.max(values(r_agrland_max_ha_perpix[[1]]))
xy <- xyFromCell(r_agrland_max_ha_perpix[[1]], 4663878)
xyFromCell(r_agrland_max_ha_perpix[[1]], 4663878)
plot(r_agrland_max_ha_perpix[[1]])
r <- rast(ncols=10, nrows=10)
values(r) <- runif(100, min=-1, max=1)
# Tulosta rasterin arvojen jakauma ennen luokittelua
cat("Ennen luokittelua:\n")
print(table(values(r)))
# Luo luokittelumatriisi
# 1. sarake: arvot, jotka haluat luokitella
# 2. sarake: uudet arvot luokitelluille arvoille
rclmat <- matrix(c(-Inf, NA, 0, 0), ncol=2, byrow=TRUE)
rclmat
r_classified <- classify(r, rclmat)
# Tulosta rasterin arvojen jakauma luokittelun jälkeen
cat("Luokittelun jälkeen:\n")
print(table(values(r_classified)))
r_potential_expansion_of_cl_ha_perpix
tic()
rclmat_delete_negative <- matrix(c(-Inf, 0, NA), ncol = 3, byrow = TRUE)
r_potential_expansion_of_cl_ha_perpix_positive <-
classify(r_potential_expansion_of_cl_ha_perpix,
rclmat_delete_negative, right = FALSE,
filename = here("Data", "Intermediate_input", "r_potential_expansion_of_cl_ha_perpix_positive.tif"))
toc()
# same as :
tic()
r_potential_expansion_of_cl_ha_perpix_positive2 <- r_potential_expansion_of_cl_ha_perpix
r_potential_expansion_of_cl_ha_perpix_positive2[r_potential_expansion_of_cl_ha_perpix_positive2 < 0] <- NA
toc()
382.67/79.86
r_potential_expansion_of_cl_ha_perpix_positive
r_potential_expansion_of_cl_ha_perpix_positive2
r_potential_expansion_of_cl_ha_perpix_positive[[1]] %>% plot()
r_potential_expansion_of_cl_ha_perpix_positive2[[1]] %>% plot()
r_potential_expansion_of_cl_ha_perpix_positive[[50]] %>% plot()
r_potential_expansion_of_cl_ha_perpix_positive2[[50]] %>% plot()
# Global sum
global(r_potential_expansion_of_cl_ha_perpix_positive, fun = "sum", na.rm = T)/1e6
# Global sum
df_agricultural_land_within_SI_class_mha <- df_agricultural_land_within_SI_class_mha %>%
mutate(cl_potential_expansionMha = global(r_potential_expansion_of_cl_ha_perpix_positive, fun = "sum", na.rm = T)/1e6 )
View(df_agricultural_land_within_SI_class_mha)
r_physical_areas_crops_sum_ha_perpix
r_potential_cl_max_ha_perpix_outside_croplands <-
mask(r_potential_expansion_of_cl_ha_perpix_positive, r_physical_areas_crops_sum_ha_perpix, inverse = T)
# Cropland expansion on cells where there is cropland
r_potential_cl_max_ha_perpix_croplandmask <-
mask(r_potential_expansion_of_cl_ha_perpix_positive, r_physical_areas_crops_sum_ha_perpix)
plot(r_potential_cl_max_ha_perpix_outside_croplands[[1]])
plot(r_potential_cl_max_ha_perpix_croplandmask[[1]])
plot(r_potential_cl_max_ha_perpix_outside_croplands[[75]])
plot(r_potential_cl_max_ha_perpix_croplandmask[[75]])
r_fraction_agrland_max
r_fraction_cl_NAto0
plot(r_fraction_agrland_max[[2]])
# Etsi fraction jossa voitais tuottaa lisää. Eli potential - mahdollinen fraction. Äsken laskettiin hehtaarit
r_fraction_potential_expansion_of_cl <-
r_fraction_agrland_max - r_fraction_cl_NAto0 # jos pos voitais tuottaa lisää. Jos neg nyt tuotetaan jo enemmän kuin SI puitteissa ehkä kannattaisi
plot(r_fraction_potential_expansion_of_cl[[2]])
# Etsi fraction jossa voitais tuottaa lisää. Eli potential - mahdollinen fraction. Äsken laskettiin hehtaarit
r_fraction_potential_expansion_of_cl <-
r_fraction_agrland_max_NAto0 - r_fraction_cl_NAto0 # jos pos voitais tuottaa lisää. Jos neg nyt tuotetaan jo enemmän kuin SI puitteissa ehkä kannattaisi
r_potential_expansion_of_cl_fraction <- r_fraction_potential_expansion_of_cl
plot(r_potential_expansion_of_cl_fraction[[75]])
# del neg vals
r_potential_expansion_of_cl_fraction <-
classify(r_potential_expansion_of_cl_fraction,
rclmat_delete_negative, right = FALSE))
# del neg vals
r_potential_expansion_of_cl_fraction <-
classify(r_potential_expansion_of_cl_fraction,
rclmat_delete_negative, right = FALSE)
plot(r_potential_expansion_of_cl_fraction[[75]])
r_potential_expansion_of_cl_fraction
# ---------------------------------------------------------------------- ratio
r_potential_share_larger_nomask <-
r_potential_expansion_of_cl_fraction /
r_fraction_cl_NAto0 # NAto0 or basic cl frac?
# !!!! same plot done bit differently below --- selvitä miksi erilainen
(plt_r_potential_share_larger_percent_nomask<-
create_index_map(r_index = 100 * r_potential_share_larger_nomask[[75]],
tocrs = "ESRI:54030",
index_main_title = "How much cropland area could increase at the cost of grazing lands",
index_label = "[%]",
colorpal = pal_share_nuuk,
breakvals = c(0, 10, 20, 60, 80, 100, Inf),
breaknames = c("<10", "10-20", "20-60", "60-80", "80-100", ">100")))
# !!!! same plot done bit differently below --- selvitä miksi erilainen
(plt_r_potential_share_larger_percent_nomask<-
create_index_map(r_index = 100 * r_potential_share_larger_nomask[[10]],
tocrs = "ESRI:54030",
index_main_title = "How much cropland area could increase at the cost of grazing lands",
index_label = "[%]",
colorpal = pal_share_nuuk,
breakvals = c(0, 10, 20, 60, 80, 100, Inf),
breaknames = c("<10", "10-20", "20-60", "60-80", "80-100", ">100")))
selected_layer <- 20
(plt_r_potential_share_larger_percent_nomask <-
create_index_map(
r_index = 100 * r_potential_share_larger_nomask[[selected_layer]],
tocrs = "ESRI:54030",
index_main_title = sprintf(
"How much cropland area could increase at the cost of grazing lands if all gl where SI > %d would be converted to cl",
selected_layer - 1
),
index_label = "[%]",
colorpal = pal_share_nuuk,
breakvals = c(0, 10, 20, 60, 80, 100, Inf),
breaknames = c("<10", "10-20", "20-60", "60-80", "80-100", ">100")
))
create_dynamic_index_map <- function(selected_layer) {
plt_r_potential_share_larger_percent_nomask <-
create_index_map(
r_index = 100 * r_potential_share_larger_nomask[[selected_layer]],
tocrs = "ESRI:54030",
index_main_title = sprintf(
"How much cropland area could increase at the cost of grazing lands if all gl where SI > %d would be converted to cl",
selected_layer - 1
),
index_label = "[%]",
colorpal = pal_share_nuuk,
breakvals = c(0, 10, 20, 60, 80, 100, Inf),
breaknames = c("<10", "10-20", "20-60", "60-80", "80-100", ">100")
)
return(plt_r_potential_share_larger_percent_nomask)
}
# Käytä funktiota valitulla kerroksella (esim. 11)
plt_result <- create_dynamic_index_map(11)
plt_result
return(plt_r_potential_share_larger_percent_nomask)
create_dynamic_index_map <- function(selected_layer) {
plt_r_potential_share_larger_percent_nomask <-
create_index_map(
r_index = 100 * r_potential_share_larger_nomask[[selected_layer]],
tocrs = "ESRI:54030",
index_main_title = sprintf(
"How much cl area could inc at cost of gl if all gl where SI > %d 'd be converted to cl",
selected_layer - 1
),
index_label = "[%]",
colorpal = pal_share_nuuk,
breakvals = c(0, 10, 20, 60, 80, 100, Inf),
breaknames = c("<10", "10-20", "20-60", "60-80", "80-100", ">100")
)
return(plt_r_potential_share_larger_percent_nomask)
}
# Käytä funktiota valitulla kerroksella (esim. 11)
(plt_result <- create_dynamic_index_map(11))
create_dynamic_index_map <- function(selected_layer) {
plt_r_potential_share_larger_percent_nomask <-
create_index_map(
r_index = 100 * r_potential_share_larger_nomask[[selected_layer]],
tocrs = "ESRI:54030",
index_main_title = sprintf(
"How much cl area could inc at cost of gl if all gl where SI > %d 'd be converted to cl",
selected_layer),
index_label = "[%]",
colorpal = pal_share_nuuk,
breakvals = c(0, 10, 20, 60, 80, 100, Inf),
breaknames = c("<10", "10-20", "20-60", "60-80", "80-100", ">100")
)
return(plt_r_potential_share_larger_percent_nomask)
}
# Käytä funktiota valitulla kerroksella (esim. 11)
(plt_result <- create_dynamic_index_map(11))
r_global_production_crops_sum_mt
r_prot_allcrops_sum_mt_perpix
## kuinka paljon enemmän kasviprotskua voitaisiin tuottaa
r_protein_prod_potentially_larger <- r_prot_allcrops_sum_mt_perpix * r_potential_share_larger_nomask
r_fraction_agrland_max_NAto0
rclmat_delete_negative
# this fraction must be in gl areas (cannot reduce gl if there is none)
r_fraction_gl_declines <-
r_fraction_agrland_max_NAto0 -
r_fraction_cl_NAto0
## Nykyisestä laitumesta vähennetään se osuus, jonka kasvintuotantoala voisi kasvaa. Se voisi kasvaa nykyisestä r_fraction_agrland_max_NAto0 saakka, eli r_fraction_agrland_max_NAto0 - r_fraction_cl_NAto0 verran
## jos negatiivinen, nii tällä hetkellä solussa enemmän tuotantoa kuin mitä SI perusteella pitäis --> laitetaan nollaksi
## toisaalta neg arvo kertoo missä gl osuus voisi kasvaa! --> nämä parempi löytää etsimällä alueet, joilla SI pieni
# Remove negative values
r_fraction_gl_declines <- classify(
r_fraction_gl_declines,
rclmat_delete_negative,
right = FALSE
)
r_fraction_gl_declines$MaxFracOfCellOvr6 %>% plot()
r_fraction_gl_declines$MaxFracOfCellOvr80 %>% plot()
r_fraction_gl_0toNA
r_fraction_gl_declines_masked_to_gl <- mask(r_fraction_gl_declines, r_fraction_gl_0toNA, maskvalues = 0)
r_how_many_percent_gl_should_decline <- 100*r_fraction_gl_declines_masked_to_gl / r_fraction_gl
r_how_many_percent_gl_should_decline_0toNA <- classify(r_how_many_percent_gl_should_decline, cbind(0,NA))
# Plot
(plt_percent_gl_should_decline <-
create_index_map(r_index = r_how_many_percent_gl_should_decline_0toNA[[10]],
tocrs = "ESRI:54030",
index_main_title = "How much grazing lands area should decline (to make space for crops)",
index_label = "%",
colorpal = pal_share_nuuk,
breakvals = c(0, 10, 20, 60, 80, 100, Inf),
breaknames = c("<10", "10-20", "20-60", "60-80", "80-100", ">100")))
create_plot_percent_gl_decline <- function(layer_num) {
plt_percent_gl_should_decline <-
create_index_map(r_index = r_how_many_percent_gl_should_decline_0toNA[[layer_num]],
tocrs = "ESRI:54030",
index_main_title = paste0("How much gl area should decline (to make space for crops) - when areas where SI>", layer_num, "'d be converted to cl"),
index_label = "%",
colorpal = pal_share_nuuk,
breakvals = c(0, 10, 20, 60, 80, 100, Inf),
breaknames = c("<10", "10-20", "20-60", "60-80", "80-100", ">100"))
return(plt_percent_gl_should_decline)
}
# Example: Use the new function to create a plot for layer 10
(plt_gl_declines <- create_plot_percent_gl_decline(75))
r_fraction_cl_increases <- r_fraction_gl_declines # same as r_fraction_SIover75_max - r_fraction_cl_NAto0
r_how_many_percent_cl_should_increase <-
100*(r_fraction_cl_increases) / r_fraction_cl_NAto0
r_how_many_percent_cl_should_increase_0toNA <- classify(r_how_many_percent_cl_should_increase, cbind(0,NA))
create_plot_percent_change <- function(raster_0toNA, layer_num, main_title) {
plt_percent_change <-
create_index_map(r_index = raster_0toNA[[layer_num]],
tocrs = "ESRI:54030",
index_main_title = sprintf(main_title, layer_num),
index_label = "",
colorpal = pal_share_nuuk,
breakvals = c(0, 10, 20, 60, 80, 100, Inf),
breaknames = c("<10", "10-20", "20-60", "60-80", "80-100", ">100"))
return(plt_percent_change)
}
(plt_cl_increase_example <- create_plot_percent_change(r_how_many_percent_cl_should_increase_0toNA, 75,
"How much cl area could inc at cost of gl if all gl where SI > %d 'd be converted to cl"))
(plt_gl_decline_example <- create_plot_percent_change(r_how_many_percent_gl_should_decline_0toNA, 75,
"How much gl area should decline (to make space for crops) - when areas where SI>%d'd be converted to cl"))
plt_gl_declines
r_fraction_gl_0toNA
r_fraction_gl_declines_masked_to_gl
r_protein_from_AGB_kg_perpix
r_protein_from_065xAGB_kg_perpix
# ------------------------------------------------------ optimized livestock
# gl area can decrease only in areas where there is some gl. Therefore mask to areas where there is gl
r_optimized_protein_yield_livestock_kg_perpix <- # check the a4 notebook for this
((r_fraction_gl_0toNA - r_fraction_gl_declines_masked_to_gl) / r_fraction_gl_0toNA) * # if this row gets value = 1, then no changes
r_protein_from_065xAGB_kg_perpix
r_optimized_protein_yield_livestock_kg_perpix
paste0("dprot_kgpix_SI", 10)
paste0("dprot_kgpix_SI", threshold_values)
r_optimized_protein_yield_dairy_kg_perpix <- # check the a4 notebook for this
((r_fraction_gl_0toNA - r_fraction_gl_declines_masked_to_gl) / r_fraction_gl_0toNA) * # if this row gets value = 1, then no changes
r_protein_from_065xAGB_kg_perpix$dairy
names(r_optimized_protein_yield_dairy_kg_perpix) <- paste0("dprot_kgpix_SI", threshold_values)
# SI
SI_5arcmin <- here("Data", "Input", "Zabel22_SI",
"SI_5arcmin_overall_suitability_hist1980_2009_current_irr_areas_applied.tif") %>%
rast()
# Crop protein production yields
r_prot_allcrops_sum_kg_ha <-
here("Data", "Intermediate_input", "protein_production_27crops_sum_kg_ha.tif") %>%
rast()
quantile(values(r_prot_allcrops_sum_kg_ha), probs = 0.95, na.rm = T) # 826.4333
r_protein_and_SI <- c(r_prot_allcrops_sum_kg_ha, SI_5arcmin)
#names(r_protein_and_SI) <- c("crop_protein_kg_ha", "overall_suitability") # if not correct already
plot(r_protein_and_SI)
#library(modelr)
all_countries <- adm10_simple_faoadded
# tehdään rasteri kullekin eri maalle (tarvitaan df arvot reg varten) --- tässä listana maapolygonit
country_sf_list <- all_countries %>%
mutate(country_sf_list = map(ADMIN, ~filter(adm10_simple_faoadded, ADMIN == .x))) %>%
pull(country_sf_list)
country_sf_list[[53]] %>% plot() # FI
# tämän listan perustella voidaan maskata rasteri r_protein_and_SI kullekin maalle
country_raster_list <- map(country_sf_list, ~crop_and_mask(r_protein_and_SI, .x))
country_raster_list[[53]] %>% plot() # FI
# Muunnetaan country_raster_list dataframeksi
# löytyy koordinaatit sekä crop_protein_kg_ha  ja overall_suitability data joka maalle
country_df_list <- map(country_raster_list, ~as.data.frame(.x, xy = T) %>% as_tibble())
country_df_list[[53]] # suomen koordinaatit, crop_protein_kg_ha  ja overall_suitability
# etsitään datasta outlierit joka maalle (taas lista)
outlier_level_list <- map_dbl(country_df_list, ~quantile(.x$crop_protein_kg_ha, probs = 0.95, na.rm = T)) # 95 or 99?
outlier_level_list[[53]] # 1243.164 Suomelle
# Filtteröidään data niin, että outlierit poistettu. Poistetaan myös x ja y
country_df_filtered_list <- map2(country_df_list, outlier_level_list, ~.x %>%
filter(crop_protein_kg_ha <= .y) %>% # not sure if I should add !is.na(overall_suitability)
dplyr::select(-c(x, y)))
country_df_filtered_list[[53]] # tässä data regressiota varten
# tehdään regressio tästä filtteröidystä datasta -- käytetään safe funktiota
# Wrapper function for linear regression
fit_lm_possibly <- function(data) {
model_output <- lm(crop_protein_kg_ha ~ overall_suitability, data = data)
model_coef <- model_output %>%
broom::tidy() %>%
dplyr::select(term, estimate, p.value)
model_stats <- model_output %>%
broom::glance()
# Combine model_coef and model_stats into a single row data frame
result <- model_coef %>%
mutate(r.squared = model_stats$r.squared,
adj.r.squared = model_stats$adj.r.squared,
AIC = model_stats$AIC,
BIC = model_stats$BIC,
nobs = model_stats$nobs,
sigma = model_stats$sigma,
statistic = model_stats$statistic,
p.value = p.value) %>%
pivot_wider(names_from = term, values_from = c(estimate, p.value)) %>%
rename(estimate_intercept = "estimate_(Intercept)",
estimate_suitability = "estimate_overall_suitability",
pvalue_suitability = "p.value_overall_suitability") %>%
dplyr::select(estimate_intercept, estimate_suitability, pvalue_suitability,
r.squared, adj.r.squared, AIC, BIC, nobs, statistic)
return(result)
}
# Safe version of the linear regression function
fit_lm_safe <- purrr::possibly(fit_lm_possibly, otherwise = NULL)
model_list <- map(country_df_filtered_list, fit_lm_safe)
model_list[[53]] # suomen tulos, mutta kahdella rivillä, olisi parempi jos kaikki olisivat yhdessä rivissä
# yhdistetään nested country_df_filtered_list polygonien kanssa
all_countries <- all_countries %>%
mutate(country_df_filtered_list = country_df_filtered_list,
model_list = model_list)
# clean
all_countries_cleaned <- all_countries %>%
dplyr::select(ADMIN, ISO_A3_EH, REGION_UN, geom, model_list)
all_countries_cleaned <- all_countries_cleaned %>%
mutate(model_list = map(model_list, ~ as_tibble(.x))) %>%
unnest(cols = model_list, keep_empty = T)
#View(all_countries_cleaned)
# 1) Etsi maat missä malli ei ole merkittävä. Näille maille vain tarvitaan etäisyys (etäisyys pval>0.05 maasta merkitykselliseen maahan)
model_significant <- all_countries_cleaned %>% filter(pvalue_suitability < 0.05) # 124 maata
model_nonsignificant <- all_countries_cleaned %>% filter(pvalue_suitability >= 0.05 | is.na(pvalue_suitability)) # 78 maata jos non sig otetaan mukaan
# Noille 78 maalle pitää löytää etäisyydet muihin maihin, joissa on merkityksellinen malli
# Sitä varten tarvitaan etäisyyksiä. Ennen etäisyyksiä pitää muodostaa keskipisteet joka maalle
p_adm0_centroids_st <- all_countries_cleaned %>%
dplyr::select(ADMIN, geom) %>%
st_centroid()
# Näistä etäisyyksistä halutaan valita ensin merkitsevien ja ei merkitsevien mallien rivit --- etäisyydet tarvitaan ainoastaan ei merkitsevistä merkitseviin
# Filter centroids for countries with significant and non-significant models
significant_centroids <- p_adm0_centroids_st %>%
filter(ADMIN %in% model_significant$ADMIN) # 124
nonsignificant_centroids <- p_adm0_centroids_st %>%
filter(ADMIN %in% model_nonsignificant$ADMIN) # 78  --------> etäisyydet tarvitaan vain näille (esim Uruguay listalla)
# laske etäisyys
# Calculate distances between non-significant and significant model centroids
distTemp <- st_distance(nonsignificant_centroids, significant_centroids) %>%
as_tibble() # 63 riviä koska 63 nonsignificant_centroids ja 121 saraketta koska 121 merkitsevää maata
# etäisyydet
# rivi = ei merkittävien maiden keskipiste   JA
# sarake = merkitsevien maiden keskipiste  VÄLILLÄ
# Eli (1,1) maan Dhekelia Sovereign Base Area keskipisteestä maan Indonesia keskipisteeseen
# Eli (1,2) maan Dhekelia Sovereign Base Area keskipisteestä maan Malaysia keskipisteeseen
# muokataan sig ja non sig maanimet matriisiin
# add sig maat sarakkeisiin
# dist_tibble <- distTemp %>%
#   as_tibble()
# colnames(dist_tibble) <- significant_centroids$ADMIN
#
# # lisää non sig maat riveille
# dist_tibble <- dist_tibble %>%
#   mutate(nonsig_cntr = nonsignificant_centroids$ADMIN) %>%
#   dplyr::select(nonsig_cntr, everything())
# Etsi lähimmän merkityksellisen mallin indeksi kullekin ei-merkitykselliselle mallille
closest_significant_indices <- apply(distTemp, 1, which.min) # joka riville pienin etäisyys, eli valitaan merkityksellisistä sarakkeista se (col), josta on lyhim matka kyseiseen merkityksettömään maahan (row)
# Liitä lähimmät merkitykselliset mallit ei-merkityksellisiin malleihin
model_nonsignificant_with_closest <- model_nonsignificant %>%
mutate(closest_significant_model = model_significant$ADMIN[closest_significant_indices], # max = 120
closest_significant_index = closest_significant_indices) # why this is needed?
# Yhdistä taulukko "merkitsevät" ei-merkitsevien kanssa, joista kuitenkin tiedetään lähin merkitsevä maa
all_countries_with_replacement <- model_significant %>%
bind_rows(model_nonsignificant_with_closest)
# TARKISTA ETTÄ TOIMII OIKEIN -- näyttää toimivan!
# lisätään intercept
updated_regression_results <- all_countries_with_replacement %>%
mutate(estimate_suitability_filled =
ifelse(pvalue_suitability >= 0.05 | is.na(pvalue_suitability),
model_significant$estimate_suitability[closest_significant_index],
estimate_suitability),
estimate_intercept_filled =
ifelse(pvalue_suitability >= 0.05 | is.na(pvalue_suitability),
model_significant$estimate_intercept[closest_significant_index],
estimate_intercept))
# 1) Etsi maat missä malli ei ole merkittävä. Näille maille vain tarvitaan etäisyys (etäisyys pval>0.05 maasta merkitykselliseen maahan)
model_significant <- all_countries_cleaned %>% filter(pvalue_suitability < 0.05) # 124 maata
model_nonsignificant <- all_countries_cleaned %>% filter(pvalue_suitability >= 0.05 | is.na(pvalue_suitability)) # 78 maata jos non sig otetaan mukaan
# Noille 78 maalle pitää löytää etäisyydet muihin maihin, joissa on merkityksellinen malli
# Sitä varten tarvitaan etäisyyksiä. Ennen etäisyyksiä pitää muodostaa keskipisteet joka maalle
p_adm0_centroids_st <- all_countries_cleaned %>%
dplyr::select(ADMIN, geom) %>%
st_centroid()
# Näistä etäisyyksistä halutaan valita ensin merkitsevien ja ei merkitsevien mallien rivit --- etäisyydet tarvitaan ainoastaan ei merkitsevistä merkitseviin
# Filter centroids for countries with significant and non-significant models
significant_centroids <- p_adm0_centroids_st %>%
filter(ADMIN %in% model_significant$ADMIN) # 124
nonsignificant_centroids <- p_adm0_centroids_st %>%
filter(ADMIN %in% model_nonsignificant$ADMIN) # 78  --------> etäisyydet tarvitaan vain näille (esim Uruguay listalla)
# laske etäisyys
# Calculate distances between non-significant and significant model centroids
distTemp <- st_distance(nonsignificant_centroids, significant_centroids) %>%
as_tibble() # 63 riviä koska 63 nonsignificant_centroids ja 121 saraketta koska 121 merkitsevää maata
# etäisyydet
# rivi = ei merkittävien maiden keskipiste   JA
# sarake = merkitsevien maiden keskipiste  VÄLILLÄ
# Eli (1,1) maan Dhekelia Sovereign Base Area keskipisteestä maan Indonesia keskipisteeseen
# Eli (1,2) maan Dhekelia Sovereign Base Area keskipisteestä maan Malaysia keskipisteeseen
# muokataan sig ja non sig maanimet matriisiin
# add sig maat sarakkeisiin
# dist_tibble <- distTemp %>%
#   as_tibble()
# colnames(dist_tibble) <- significant_centroids$ADMIN
#
# # lisää non sig maat riveille
# dist_tibble <- dist_tibble %>%
#   mutate(nonsig_cntr = nonsignificant_centroids$ADMIN) %>%
#   dplyr::select(nonsig_cntr, everything())
# Etsi lähimmän merkityksellisen mallin indeksi kullekin ei-merkitykselliselle mallille
closest_significant_indices <- apply(distTemp, 1, which.min) # joka riville pienin etäisyys, eli valitaan merkityksellisistä sarakkeista se (col), josta on lyhim matka kyseiseen merkityksettömään maahan (row)
# Liitä lähimmät merkitykselliset mallit ei-merkityksellisiin malleihin
model_nonsignificant_with_closest <- model_nonsignificant %>%
mutate(closest_significant_model = model_significant$ADMIN[closest_significant_indices], # max = 120
closest_significant_index = closest_significant_indices) # why this is needed?
# Yhdistä taulukko "merkitsevät" ei-merkitsevien kanssa, joista kuitenkin tiedetään lähin merkitsevä maa
all_countries_with_replacement <- model_significant %>%
bind_rows(model_nonsignificant_with_closest)
# TARKISTA ETTÄ TOIMII OIKEIN -- näyttää toimivan!
# lisätään intercept
updated_regression_results <- all_countries_with_replacement %>%
mutate(estimate_suitability_filled =
ifelse(pvalue_suitability >= 0.05 | is.na(pvalue_suitability),
model_significant$estimate_suitability[closest_significant_index],
estimate_suitability),
estimate_intercept_filled =
ifelse(pvalue_suitability >= 0.05 | is.na(pvalue_suitability),
model_significant$estimate_intercept[closest_significant_index],
estimate_intercept))
head(updated_regression_results)
names(updated_regression_results)
# testaa kuinka yhdistetään regressiotulokset sekä lasketaan crop protein sato alueille, joissa ei nyt ole cl
r_suitability_filled <-
rasterize(updated_regression_results, r_fraction_gl_declines_masked_to_gl, field="estimate_suitability_filled")
plot(r_suitability_filled)
hist(r_suitability_filled)
plot(r_suitability_filled)
updated_regression_results %>% filter(ADMIN == "Greece")
kok <- updated_regression_results %>% filter(ADMIN == "Greece")
View(kok)
kok1 <- updated_regression_results %>% filter(ADMIN == "North Makedonia")
kok1 <- updated_regression_results %>% filter(ADMIN == "North Macedonia")
View(kok1)
r_intercept_filled <-
rasterize(updated_regression_results, r_fraction_gl_declines_masked_to_gl, field="estimate_intercept_filled")
plot(r_intercept_filled)
kok1
# Näiden perusteella proteiinisato olisi
r_prot_based_on_SI <- r_intercept_filled + r_suitability_filled * SI_5arcmin
plot(r_prot_based_on_SI)
plot(r_prot_based_on_SI, main = "estimoitu prot kasvit")
plot(r_prot_allcrops_sum_mt_perpix, "alk per prot sato kasvit")
plot(r_prot_based_on_SI, main = "estimoitu prot kasvit")
plot(r_prot_allcrops_sum_mt_perpix, main = "alk per prot sato kasvit")
r_prot_based_on_SI
r_prot_based_on_SI <- r_intercept_filled + r_suitability_filled * SI_5arcmin
# tuunataan
r_prot_based_on_SI[r_prot_based_on_SI<0]<- NA
test1 <- r_prot_allcrops_sum_mt_perpix
test1[test1>920]<-920
plot(r_prot_based_on_SI, main = "estimoitu prot kasvit")
plot(test1, main = "alk per prot sato kasvit")
summary(r_prot_based_on_SI )
r_suitability_filled <-
rasterize(updated_regression_results, r_fraction_gl_declines_masked_to_gl, field="estimate_suitability_filled")
r_intercept_filled <-
rasterize(updated_regression_results, r_fraction_gl_declines_masked_to_gl, field="estimate_intercept_filled")
r_optimized_protein_yield_crops_mt_perpix <-
ifel(test = r_fraction_cl_NAto0 == 0  &  r_fraction_gl_declines_masked_to_gl > 0, # if there is possibility to expand cl on gl areas
yes = (r_intercept_filled + r_suitability_filled * SI_5arcmin), # approximate yield to these areas
no = ((r_fraction_cl_NAto0 + r_fraction_gl_declines_masked_to_gl) / r_fraction_cl_NAto0) * r_prot_allcrops_sum_mt_perpix)
r_fraction_gl_declines_masked_to_gl
